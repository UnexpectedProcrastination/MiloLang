#load "windows.milo"

Vector2 :: union {
	using _xy: struct {
		x: f32
		y: f32
	}
	
	elements: [2]f32 = --
}


Vector3 :: union {
	using _xyz: struct {
		x: f32
		y: f32
		z: f32
	}
	
	elements: [3]f32 = --
	
	xy: Vector2 = --
}

Vector4 :: union {
	using xyzw : struct {
		x: f32
		y: f32
		z: f32
		w: f32
	}
	
	using rgba : struct {
		r: f32
		g: f32
		b: f32
		a: f32
	} = --
	
	elements: [4]f32 = --
	
	xyz: Vector3 = --
	xy: Vector2 = --
}


min :: (a: u64, b: u64) -> #must u64 {
	if a < b 
		return a
	else 
		return b
}

max :: (a: u64, b: u64) -> #must u64 {
	if a > b 
		return a
	else 
		return b
}

string_length :: (s: string) -> #must u64 {
	len: u64 = 0
	while s[len] len += 1

	return len
}



print_string :: (s: string) {
	buffer: []u8
	
	buffer.data = cast() s
	buffer.count = string_length(s)

	print_buffer(buffer)
}

copy_string :: (s: string) -> #must string {
	memory: *u8 = allocate(string_length(s) + 1)
	
	buf := memory
	
	for s {
		<< memory = it
		memory += 1
	}
	
	<< memory = 0
	
	return cast() buf
}

args: []string

memory_copy :: (dst: *void, src: *void, count: u64) {
	a : *u8 = dst
	b: *u8 = src
	
	for i: 0 .. count {
		a[i] = b[i]
	}
}

get_array_pointer :: (data: *u8, index: u64, size: u64) -> *void {
	return data + index * size
}

array_add_generic :: (array: *[..]u8, value: *void, size: u64) -> *void {
	if array.count >= array.capacity {
		array.capacity = max(array.count * 2, 4)
		
		array.data = reallocate(array.data, array.capacity * size)
	}
	
	dest := get_array_pointer(array.data, array.count, size)
	
	memory_copy(dest, value, size)
	array.count += 1
	
	return dest
}

array_add_string :: (array: *[..]string, value: *string) -> *string {
	return array_add_generic(cast() array, value, size_of(type_of(value)))
}

panic :: () {
	print_string("Panic")
	
	ExitProcess(1)
}

assert :: (value: bool) {
	if !value
		panic()
}

array_remove_generic_by_pointer :: (array: *[]u8, value: *void, size: u64) {
	assert(value >= array.data)
	assert(value < get_array_pointer(array.data, array.count, size))
	assert(cast() (value - cast() array.data) % size == 0)
	
	array.count -= 1
	
	end := get_array_pointer(array.data, array.count, size)
	
	if value != end
		memory_copy(value, end, size)
	
}

array_remove_string_by_pointer :: (array: *[]string, value: *string) {
	array_remove_generic_by_pointer(cast() array, value, size_of(string))
}


main :: () {
	//args.data = argv
	//args.count = cast(u64) argc
	init_runtime()

	_main()
	
	ExitProcess(0)
}

get_command_line_arguments :: () -> []string {
	return args
}

s64_to_string :: (value: s64) -> #must string {
	if value == 0 {
		result := cast(*u8) allocate(2)
		result[0] = '0'
		result[1] = 0
		
		return cast() result
	}
	
	negative := value < 0
	
	unsigned: u64 = cast()value
	
	if negative
		unsigned = -unsigned
		
	digitCount: u64
	
	remaining := unsigned
	
	while remaining {
		digitCount += 1
		
		remaining /= 10
	}
	
	if negative
		digitCount += 1
	
	result := cast(*u8) allocate(digitCount + 1)
	
	result += digitCount;
	
	<<result = 0
	remaining = unsigned
	
	while remaining {
		result -= 1;
		
		<<result = cast() (remaining % 10 + '0')
		remaining /= 10
	}
	
	if negative {
		result -= 1;
		<< result = '-'
	}
	
	return cast() result
}

u64_to_string :: (value: u64) -> #must string {
	if value == 0 {
		result := cast(*u8) allocate(2)
		result[0] = '0'
		result[1] = 0
		
		return cast() result
	}

	digitCount: u64
	
	remaining := value
	
	while remaining {
		digitCount += 1
		
		remaining /= 10
	}
	
	result := cast(*u8) allocate(digitCount + 1)
	
	result += digitCount;
	
	<<result = 0
	remaining = value
	
	while remaining {
		result -= 1;
		
		<<result = cast() (remaining % 10 + '0')
		remaining /= 10
	}
	
	return cast() result
}

print_u64 :: (num: u64) {
	s := u64_to_string(num)
	print_string(s)
	
	deallocate(cast() s)	
}

print_s64 :: (num: s64) {
	s := s64_to_string(num)
	print_string(s)
	
	deallocate(cast() s)	
}

print :: (using val: any) {
	info := type_info(value_type)

	if (value_type == void) {
	
		print_string("void")
		
	} else if (value_type == type) {
	
		print_string(type_info(<<cast(*type) value_pointer).name)
		
	} else if (value_type == bool) {
		value := <<cast(*bool) value_pointer
	
		if (value) {
			print_string("true")
		} else {
			print_string("false")
		}
		
	} else if (value_type == type) {
	
		print_string(type_info(<<cast(*type) value_pointer).name)
		
	} else if (value_type == string) {
	
		print_string(<<cast(*string) value_pointer)
		
	} else {
	
		print_string("Cannot print ")
		print_string(info.name)
		
	}
}