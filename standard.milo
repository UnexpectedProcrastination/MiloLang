#load "windows.milo"

Vector2 :: union {
	using _xy: struct {
		x: f32
		y: f32
	}
	
	elements: [2]f32 = --
	
	print_me :: (using vector: *Vector2) {
		print("(")
		print(x)
		print(", ")
		print(y)
		print(")")
	}
}


Vector3 :: union {
	using _xyz: struct {
		x: f32
		y: f32
		z: f32
	}
	
	elements: [3]f32 = --
	
	xy: Vector2 = --
	
	print_me :: (using vector: *Vector3) {
		print("(")
		print(x)
		print(", ")
		print(y)
		print(", ")
		print(z)
		print(")")
	}
}

Vector4 :: union {
	using xyzw : struct {
		x: f32
		y: f32
		z: f32
		w: f32
	}
	
	using rgba : struct {
		r: f32
		g: f32
		b: f32
		a: f32
	} = --
	
	elements: [4]f32 = --
	
	xyz: Vector3 = --
	xy: Vector2 = --
	
	
	print_me :: (using vector: *Vector4) {
		print("(")
		print(x)
		print(", ")
		print(y)
		print(", ")
		print(z)
		print(", ")
		print(w)
		print(")")
	}
}


min :: (a: u64, b: u64) -> #must u64 {
	if a < b 
		return a
	else 
		return b
}

max :: (a: u64, b: u64) -> #must u64 {
	if a > b 
		return a
	else 
		return b
}

string_length :: (s: string) -> #must u64 {
	len: u64 = 0
	while s[len] len += 1

	return len
}



print_string :: (s: string) {
	buffer: []u8
	
	buffer.data = cast() s
	buffer.count = string_length(s)

	print_buffer(buffer)
}

copy_string :: (s: string) -> #must string {
	memory: *u8 = allocate(string_length(s) + 1)
	
	buf := memory
	
	for s {
		<< memory = it
		memory += 1
	}
	
	<< memory = 0
	
	return cast() buf
}

args: []string

memory_copy :: (dst: *void, src: *void, count: u64) {
	a : *u8 = dst
	b: *u8 = src
	
	for i: 0 .. count {
		a[i] = b[i]
	}
}

get_array_pointer :: (data: *u8, index: u64, size: u64) -> *void {
	return data + index * size
}

array_add_generic :: (array: *[..]u8, value: *void, size: u64) -> *void {
	if array.count >= array.capacity {
		array.capacity = max(array.count * 2, 4)
		
		array.data = reallocate(array.data, array.capacity * size)
	}
	
	dest := get_array_pointer(array.data, array.count, size)
	
	memory_copy(dest, value, size)
	array.count += 1
	
	return dest
}

array_add_string :: (array: *[..]string, value: *string) -> *string {
	return array_add_generic(cast() array, value, size_of(type_of(value)))
}

panic :: () {
	print_string("Panic")
	
	ExitProcess(1)
}

assert :: (value: bool) {
	if !value
		panic()
}

array_remove_generic_by_pointer :: (array: *[]u8, value: *void, size: u64) {
	assert(value >= array.data)
	assert(value < get_array_pointer(array.data, array.count, size))
	assert(cast() (value - cast() array.data) % size == 0)
	
	array.count -= 1
	
	end := get_array_pointer(array.data, array.count, size)
	
	if value != end
		memory_copy(value, end, size)
	
}

array_remove_string_by_pointer :: (array: *[]string, value: *string) {
	array_remove_generic_by_pointer(cast() array, value, size_of(string))
}


main :: () {
	//args.data = argv
	//args.count = cast(u64) argc
	init_runtime()

	_main()
	
	ExitProcess(0)
}

get_command_line_arguments :: () -> []string {
	return args
}

DIGIT_TABLE :: "0123456789abcdefghijklmnopqrstuvwxyz"

u64_to_string :: (value: u64, base: u64 = 10) -> #must string {
	if base > 36 {
		return ""
	}

	if value == 0 {
		result := cast(*u8) allocate(2)
		result[0] = '0'
		result[1] = 0
		
		return cast() result
	}

	digitCount: u64
	
	remaining := value
	
	while remaining {
		digitCount += 1
		
		remaining /= base
	}
	
	result := cast(*u8) allocate(digitCount + 1)
	
	result += digitCount;
	
	<<result = 0
	remaining = value
	
	while remaining {
		result -= 1;
		
		<<result = cast() (DIGIT_TABLE[remaining % base])
		remaining /= base
	}
	
	return cast() result
}

print_u64 :: (num: u64, base: u64 = 10) {
	s := u64_to_string(num, base)
	print_string(s)
	
	deallocate(cast() s)	
}

read_integer :: (info: *Type_Info_Integer, value: *void) -> u64 {
	mask: u64 = --
	number: u64 = --

	if info.size == 1 {
		number = <<cast(*u8) value
		mask = 1 << 7
	} else if info.size == 2 {
		number = <<cast(*u16) value
		mask = 1 << 15
	} else if info.size == 4 {
		number = <<cast(*u32) value
		mask = 1 << 31
	} else if info.size == 8 {
		number = <<cast(*u64) value
		mask = 1 << 63
	}
	
	if info.signed && (number & mask)
		number |= ~(mask | (mask - 1))
	
	return number
}

// @Unicode
print_char :: (value: u8) {
	char := value
	buffer: []u8
	buffer.count = 1
	buffer.data = *char
	
	print_buffer(buffer)
}
// This function is terrible

print_f64 :: (num: f64, decimal_places: u64 = 6) {
	value := num

	if is_nan(value) {
		print_string("NaN")
		return
	}

	if (value < 0) {
		print_string("-")
		value = -value
	}
	
	if is_infinite(value) {
		print_string("infinity")
		return
	}
	
	if num >= 1p64 {
		print_string("unhandled case in print_f64")
		return
	}
	
	integer_part := cast(u64) value
	
	print_u64(integer_part)
	
	print_string(".")
	
	for decimal_places {
		value *= 10
		
		integer := cast(u64) value
		
		print_char(cast() ('0' + integer % 10))
	}
}

print :: (using val: any) {
	if value_type == type_info(void) 
		print_string("void")
	else if value_type == type_info(type) {
	
		print_string(type_info(<<cast(*type) value_pointer).name)
		
	} else if value_type == type_info(bool) {
		value := <<cast(*bool) value_pointer
	
		if value
			print_string("true")
		else
			print_string("false")
		
	} else if value_type == type_info(type) {
	
		print_string(type_info(<<cast(*type) value_pointer).name)
		
	} else if value_type == type_info(string) {
	
		print_string(<<cast(*string) value_pointer)
		
	} else if value_type.tag == .INTEGER {		
		value := read_integer(cast() value_type, value_pointer)
		
		if (cast(*Type_Info_Integer) value_type).signed && (value & (1 << 63)) {
			print_string("-")
			value = -value
		}
		
		print_u64(value)
	} else if value_type.tag == .ENUM {
		info := cast(*Type_Info_Enum) value_type
		
		value := read_integer(info.base_type, value_pointer)

		if info.is_flags {
			first := true
			
			for info.values {
				if value & it.value {
					value &= ~it.value
				
					if !first print_string(" | ")
					
					if info.name {
						if first
							print_string(info.name)
							
						print_string(".")
					}
					
					first = false
					
					print_string(it.name)
				}
			}
			
			if first {
				if value {
					if info.name {
						print_string(info.name)
						print_string(".")
					}
					
					print_string("(INVALID enum_flags ")
					print_u64(value, 16)
					print_string(")")
				} else
					print_string("0")
			} else if value {
				print_string(" | ")
				
				if info.name
					print_string(".")
				
				print_string("(INVALID enum_flags ")
				print_u64(value, 16)
				print_string(")")
			}
		} else {
			for info.values {
				if value == it.value {
					if info.name {
						print_string(info.name)
						print_string(".")
					}
				
					print_string(it.name)
					break
				}
			} completed {
				print_string("(INVALID enum ")
				
				num: any = --
				num.value_pointer = value_pointer
				num.value_type = info.base_type
				
				print(num)
				
				print_string(")")
			}
		}
		
		
	} else if value_type.tag == .POINTER || value_type.tag == .FUNCTION {
	
		print_u64(<<cast(*u64) value_pointer)
		
	} else if value_type.tag == .ARRAY {
	
		info := cast(*Type_Info_Array) value_type
		
		count: u64 = --
		
		if info.flavor == .FIXED {
			count = info.count
		} else {
			count = (cast(*[]u8) value_pointer).count
		}
		
		print_string("[")
		print_u64(count)
		print_string("]")
		print_string(info.element_type.name)
		
	} else if value_type.tag == .STRUCT {	
		info := cast(*Type_Info_Struct) value_type
		
		for info.members {
			if it.name == "print_me" && it.member_type.tag == .FUNCTION {
				func := cast(*Type_Info_Function) it.member_type
				
				if func.arguments.count == 1 && func.arguments[0].tag == .POINTER && 
					(cast(*Type_Info_Pointer) func.arguments[0]).value_type == cast() info && 
					func.returns.count == 1 && func.returns[0] == type_info(void) {
					f: (*void) -> void 
					
					if it.flags & .CONSTANT {
						f = <<cast(*type_of(f)) it.initial_value
					} else {
						f = <<cast(*type_of(f)) (value_pointer + it.offset)
					}
					
					f(value_pointer)
					break
				}
			}
		} completed {
		
			print_string("{ ")
		
			for info.members {
				if !(it.flags & .CONSTANT) {
					print_string(it.name)
					print_string(" = ")
				
					val: any = --
					val.value_pointer = value_pointer + it.offset
					val.value_type = it.member_type
					
					print(val)
					
					print_string(" ")
				}
			}
			
			print_string("}")

		}		
	} else if value_type == type_info(f64) {
	
		print_f64(<<cast(*f64)value_type)
		
	} else if value_type == type_info(f32) {
	
		print_f64(cast()<<cast(*f32)value_type)
		
	} else {
	
		print_string("Cannot print ")
		print_string(value_type.name)
		
	}
}