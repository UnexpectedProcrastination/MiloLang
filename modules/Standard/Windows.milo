#import "Windows"
#import "String"

allocate :: (size: u64) -> #must *void {
	if !process_heap process_heap = GetProcessHeap()
	return HeapAlloc(process_heap, 0, size)
}



reallocate :: (block: *void, size: u64) -> #must *void {
	if block == null
		return allocate(size)
	else {			
		if !process_heap process_heap = GetProcessHeap()
		return HeapReAlloc(process_heap, 0, block, size)
	}
}

deallocate :: (block: *void) {
	if !process_heap process_heap = GetProcessHeap()
	HeapFree(process_heap, 0, block)
}

exit :: (code: u32 = 0) {
	ExitProcess(code)
}

convert_windows_string :: (windows_string: *u16) -> string {
	result: [..]u8 // @Efficiency: Don't do this
	
	pointer := windows_string
	
	while <<pointer {
		utf32: u32 = <<pointer
		
		if 0xD800 <= utf32 && utf32 < 0xDC00 {
			high := (utf32 - 0xD800) << 10
			
			pointer += 1
			
			low: u32 = <<pointer - 0xDC00
			
			utf32 = high + low + 0x1_0000
		}
		
		append(*result, utf32)
		
		pointer += 1
	}
	
	return .{result.data, result.count}
}

// @Unicode
print_buffer :: (buffer: []u8) {
	if !std_out {
		std_out = GetStdHandle(STD_OUTPUT_HANDLE)
		SetConsoleOutputCP(CP_UTF8)
	}
	
	bytes_written: u32
	WriteFile(std_out, buffer.data, cast() buffer.count, *bytes_written)
}

get_command_line_arguments :: () -> []string {
	count: s32

	windows_args := CommandLineToArgvW(GetCommandLineW(), *count)
	
	if !windows_args {
		return .{}
	}
	
	args := []string.{allocate(size_of(string) * cast(u64) count), cast() count}
	
	for * args {
		<<it = convert_windows_string(windows_args[it_index])
	}

	return args
}

#scope_module

std_out: HANDLE
process_heap: HANDLE