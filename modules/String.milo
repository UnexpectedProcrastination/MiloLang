read_line :: (s: string) -> (line: string, remaining: string) {
	remaining := s
	line := s
	line.count = 0

	while remaining && remaining[0] != '\r' && remaining[0] != '\n' {
		remaining = remaining[1..]
		line.count += 1
	}
	
	if remaining.count >= 2 && remaining[0..2] == "\r\n"
		remaining = remaining[2..]
	else if remaining
		remaining = remaining[1..]
		
	return line, remaining
}

// Read a charcter from a UTF-8 string
read_character :: (s: string) -> (character: u32, remaining: string) {	ONE_BYTE           :: 0b0000_0000
	ONE_BYTE_MASK      :: 0b1000_0000
	
	TWO_BYTE           :: 0b1100_0000
	TWO_BYTE_MASK      :: 0b1110_0000
	
	THREE_BYTE         :: 0b1110_0000
	THREE_BYTE_MASK    :: 0b1111_0000
	
	FOUR_BYTE          :: 0b1111_0000
	FOUR_BYTE_MASK     :: 0b1111_1000
	
	TRAILING_BYTE      :: 0b1000_0000
	TRAILING_BYTE_MASK :: 0b1100_0000
	

	if !s return cast() -1, s
	
	first := cast(u32) s[0]

	if first & ONE_BYTE_MASK == ONE_BYTE { // Single byte character
		return first, s[1..]
	} else if first & TWO_BYTE_MASK == TWO_BYTE {
		first &= ~TWO_BYTE_MASK
	
		if s.count < 2 return cast() -1, s
		
		second := cast(u32) s[1]
		
		if second & TRAILING_BYTE_MASK != TRAILING_BYTE return cast() -1, s
		
		second &= ~TRAILING_BYTE_MASK
		return first << 6 | second, s[2..]
	} else if first & THREE_BYTE_MASK == THREE_BYTE {
		first &= ~THREE_BYTE_MASK
		
		if s.count < 3 return cast() -1, s
		
		second := cast(u32) s[1]
		third  := cast(u32) s[2]
		
		if second & TRAILING_BYTE_MASK != TRAILING_BYTE return cast() -1, s
		if third  & TRAILING_BYTE_MASK != TRAILING_BYTE return cast() -1, s
		
		second &= ~TRAILING_BYTE_MASK
		third  &= ~TRAILING_BYTE_MASK
		
		return first << 12 | second << 6 | third, s[3..]
	} else if first & FOUR_BYTE_MASK == FOUR_BYTE {
		first &= ~FOUR_BYTE_MASK
		
		if s.count < 4 return cast() -1, s
		
		second  := cast(u32) s[1]
		third   := cast(u32) s[2]
		fourth  := cast(u32) s[3]
		
		if second & TRAILING_BYTE_MASK != TRAILING_BYTE return cast() -1, s
		if third  & TRAILING_BYTE_MASK != TRAILING_BYTE return cast() -1, s
		if fourth & TRAILING_BYTE_MASK != TRAILING_BYTE return cast() -1, s
		
		second &= ~TRAILING_BYTE_MASK
		third  &= ~TRAILING_BYTE_MASK
		fourth &= ~TRAILING_BYTE_MASK
		
		return first << 18 | second << 12 | third << 6 | fourth, s[4..]
	} else {
		return cast() -1, s
	}
}

read_u64 :: (s: string) -> (value: u64, remaining: string) {
	remaining := s
	
	value: u64
	
	
	while remaining && '0' <= remaining[0] && remaining[0] <= '9' {
		value *= 10
		value += remaining[0] - '0'
		remaining = remaining[1..]
	}

	return value, remaining
}

// @Unicode
split_at_first :: (s: string, c: u8) -> (before: string, after: string) {
	before := s
	after := s
	
	before.count = 0
	
	for s {
		defer after = after[1..]
		
		if it == c
			break;
		
		before.count += 1
	}
	
	return before, after
}