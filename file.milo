#load "standard.milo"


#if TARGET_WINDOWS {
	// @Incomplete add multiple return values 
	read_entire_file :: (file: string) (-> #must result: []u8, success := true) {
		
		CloseHandle :: (hObject: *void) -> s32 #external "kernel32"
		CreateFileW :: (lpFileName: *u16, dwDesiredAccess: u32, dwShareMode: u32, lpSecurityAttributes := null, 
						dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile := null) -> *void #external "kernel32"
						
		GetFileSizeEx :: (hFile: *void, lpFileSize: *s64) -> s32 #external "kernel32"

		ReadFile :: (hFile: *void, lpBuffer: *void, nNumberOfBytesToRead: u32, lpNumberOfBytesRead: *u32, lpOverlapped := null) -> s32 #external "kernel32"
		
		INVALID_HANDLE_VALUE :: cast(*void) -1

		GENERIC_READ :: 0x8000_0000

		FILE_SHARE_READ :: 0x2
		
		OPEN_EXISTING :: 3
		FILE_ATTRIBUTE_NORMAL    :: 0x0000_0080
		FILE_FLAG_SEQUENTIAL_SCAN    :: 0x0800_0000
	
		result: []u8
		
		filename := create_wide_string(file)
		
		handle := CreateFileW(filename, GENERIC_READ, 0, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN)
		
		deallocate(filename)
		
		if handle == INVALID_HANDLE_VALUE {
			return result, false
		} else {
		
			if GetFileSizeEx(handle, cast() *result.count) {
				result.data = allocate(result.count)
				remaining := result
				
				
				while remaining {
					bytes_read: u32
					
					bytes_to_read := remaining.count
					
					if (bytes_to_read > 0xFFFF_FFFF) {
						bytes_to_read = 0xFFFF_FFFF
					}
					
					if !ReadFile(handle, remaining.data, cast() bytes_to_read, *bytes_read) || bytes_read != bytes_to_read {
						result.count = 0
						deallocate(result.data)
						result.data = null
						
						CloseHandle(handle)
						
						return result, false
					}
					
					remaining.count -= bytes_to_read
					remaining.data += bytes_to_read
				}
			} else {
				CloseHandle(handle)
			
				return result, false
			}
			
			CloseHandle(handle)
		}
		
		return result
	}

	write_entire_file :: (file: string, data: []u8) -> bool {
		
		CloseHandle :: (hObject: *void) -> s32 #external "kernel32"
		CreateFileW :: (lpFileName: *u16, dwDesiredAccess: u32, dwShareMode: u32, lpSecurityAttributes := null, 
						dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile := null) -> *void #external "kernel32"
						
		WriteFile :: (hFile: *void, lpBuffer: *void, nNumberOfBytesToWrite: u32, lpNumberOfBytesWritten: *u32, lpOverlapped := null) -> s32 #external "kernel32"
		
		INVALID_HANDLE_VALUE :: cast(*void) -1
		
		GENERIC_WRITE   :: 0x4000_0000
		
		CREATE_ALWAYS     :: 2
		
		FILE_ATTRIBUTE_NORMAL    :: 0x0000_0080
		FILE_FLAG_SEQUENTIAL_SCAN    :: 0x0800_0000
	
		
	
		write := data
		
		filename := create_wide_string(file)
		
		handle := CreateFileW(filename, GENERIC_WRITE, 0, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN)
		
		if handle == INVALID_HANDLE_VALUE {
			return false
		} else {
			while write {
				bytes_written: u32
				
				bytes_to_write := write.count
				
				if (bytes_to_write > 0xFFFF_FFFF) {
					bytes_to_write = 0xFFFF_FFFF
				}
				
				if !WriteFile(handle, write.data, cast() bytes_to_write, *bytes_written) || bytes_written != bytes_to_write {
					CloseHandle(handle)
					
					return false
				}
				
				write.count -= bytes_to_write
				write.data += bytes_to_write
			}
			
			CloseHandle(handle)
		}
		
		return true
	}
} else {
	unsupported_os: u64 = "error"
}