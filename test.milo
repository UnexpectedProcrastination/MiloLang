#load "windows.milo"
#load "gl.milo"
#load "standard.milo"
#load "random/random.milo"
#load "bitmap.milo"

should_quit: bool

window_width: s32 = 1280
window_height: s32 = 720

counter_scale: f32

load_image :: (filename: string) -> u32 {
	success: bool
	
	file := read_entire_file(filename, *success)
	
	if !success {
		return 0
	}
	
	if file.count < size_of(Bmp_File_Header) + size_of(Bmp_Dib_Header) {
		deallocate(file.data)
		return 0
	}

	file_header := cast(*Bmp_File_Header)file.data
	dib_header := cast(*Bmp_Dib_Header)(file.data + size_of(Bmp_File_Header))
	
	if file_header.header != Bmp_File_Header.EXPECTED_HEADER || file_header.file_size != file.count {
		deallocate(file.data)
		return 0
	}
	
	if dib_header.bits_per_pixel != 32 || 
		dib_header.compression_method != Bmp_Dib_Header.Compression.BI_BITFIELDS || 
		dib_header.alpha_mask != 0xFF000000 ||
		dib_header.red_mask   != 0x00FF0000 ||
		dib_header.green_mask != 0x0000FF00 ||
		dib_header.blue_mask  != 0x000000FF ||
		dib_header.height <= 0 {
		
		deallocate(file.data)
		return 0
	}
	
	texture: u32
	
	glGenTextures(1, *texture)
	glBindTexture(GL_TEXTURE_2D, texture)
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, dib_header.width, dib_header.height, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, file.data + file_header.offset_to_image)
	
	deallocate(file.data)
	
	return texture
}

left_is_down:  bool
right_is_down: bool
space_is_down: bool
shift_is_down: bool

PLAYER_SPEED :: 10.0
BULLET_SPEED :: 400.0

x: f32 = 100.0

Rectangle :: struct {
	x: f32
	y: f32
	width: f32
	height: f32
}

Entity :: struct {
	using rectangle: Rectangle
	
	Flags :: enum_flags u64 {
		DRAW_RECTANGLE
	}
	
	color: Vector4
	
	flags: Flags
	texture_handle: u32
	
	occupied: bool
}

Particle :: struct {
	using location: Rectangle
	location_step: Rectangle
	current_color: Vector4
	color_step: Vector4
	lifetime: f32
}

Particle_System :: struct {
	relative: u64
	x: f32
	y: f32
	texture_handle: u32
	active: bool
	occupied: bool
	
	spawn_progress: f32
	spawn_rate: f32	
	
	spawn_radius: f32
	spawn_size: f32
	spawn_mean_velocity: Vector2
	spawn_velocity_range: Vector2
	spawn_lifetime: f32
	spawn_color: Vector4
	
	particles: [..]Particle
}

rng: Random_State

create_particle :: (using particle_system: *Particle_System) {
	particle: Particle
	
	particle.x = x + random_bilateral(*rng) * spawn_radius
	particle.y = y + random_bilateral(*rng) * spawn_radius
	particle.width = spawn_size
	particle.height = spawn_size
	
	particle.location_step.x = spawn_mean_velocity.x + random_bilateral(*rng) * spawn_velocity_range.x
	particle.location_step.y = spawn_mean_velocity.y + random_bilateral(*rng) * spawn_velocity_range.y

	
	particle.current_color = spawn_color
	
	particle.lifetime = spawn_lifetime
	
	array_add_generic(cast() *particles, *particle, size_of(Particle))
}

update_particle :: (using particle: *Particle, delta: f32) {
	particle.lifetime -= delta

	
	particle.x      += delta * particle.location_step.x
	particle.y      += delta * particle.location_step.y
	particle.width  += delta * particle.location_step.width
	particle.height += delta * particle.location_step.height
	
	particle.current_color.r += delta * particle.color_step.r
	particle.current_color.g += delta * particle.color_step.g
	particle.current_color.b += delta * particle.color_step.b
	particle.current_color.a += delta * particle.color_step.a
}

update_particle_system :: (using particle_system: *Particle_System, delta: f32) {
	for * particle: particles {
		update_particle(particle, delta)
		
		if particle.lifetime <= 0 {
			remove
			continue
		}
	}
	
	if particle_system.active {
		particle_system.spawn_progress += delta * particle_system.spawn_rate
		
		while particle_system.spawn_progress > 1 {
			particle_system.spawn_progress -= 1
			create_particle(particle_system)
		}
	} else {
		
	}
}

draw_particle_system :: (using particle_system: *Particle_System) {
	

	glPushMatrix()
	glTranslatef(entities[relative].x, entities[relative].y, 0)

	if particle_system.texture_handle {
		glBindTexture(GL_TEXTURE_2D, particle_system.texture_handle)
		
		glBegin(GL_QUADS)
		
		for * particle : particles {
			set_gl_color(particle.current_color)
		
			textured_quad(particle)
		}
		
		glEnd()
		
	} else {
		glDisable(GL_TEXTURE_2D)
		
		glBegin(GL_QUADS)
		
		for * particle : particles {
			set_gl_color(particle.current_color)
		
			untextured_quad(particle)
		}
		
		glEnd()
		
		glEnable(GL_TEXTURE_2D)
	}
	
	glPopMatrix()
}

add_entity :: (entity: *Entity) -> u64 {
	for * entities {
		if !it.occupied {
			<<it = <<entity
			it.occupied = true
			
			return it_index
		}
	}
	
	array_add_generic(cast() *entities, entity, size_of(Entity))
	entities[entities.count - 1].occupied = true
	
	return entities.count - 1
}

remove_entity :: (index: u64) {
	entities[index].occupied = false
}

remove_particle_system :: (index: u64) {
	particle_systems[index].occupied = false
}

add_particle_system :: (particle_system: *Particle_System) -> u64 {
	for * particle_systems {
		if !it.occupied {
			<<it = <<particle_system
			it.occupied = true
			
			return it_index
		}
	}
	
	array_add_generic(cast() *particle_systems, particle_system, size_of(Particle_System))
	particle_systems[particle_systems.count - 1].occupied = true
	
	return particle_systems.count - 1
}

set_gl_color :: (color: Vector4) {
	glColor4f(color.r, color.g, color.b, color.a)
}

make_vector2 :: (x: f32, y: f32) -> Vector2 {
	vector: Vector2 = --
	vector.x = x
	vector.y = y
	
	return vector
}

make_vector4 :: (x: f32, y: f32, z: f32, w: f32) -> Vector4 {
	vector: Vector4 = --
	vector.x = x
	vector.y = y
	vector.z = z
	vector.w = w
	
	return vector
}

untextured_quad :: (using rectangle: *Rectangle) {
	half_width := width * 0.5
	half_height := height * 0.5

	glVertex2f(x - half_width, y - half_height)
	
	glVertex2f(x + half_width, y - half_height)
	
	glVertex2f(x + half_width, y + half_height)
	
	glVertex2f(x - half_width, y + half_height)
}

textured_quad :: (using rectangle: *Rectangle) {
	half_width := width * 0.5
	half_height := height * 0.5
	
	glTexCoord2f(0, 0)
	glVertex2f(x - half_width, y - half_height)
	
	
	glTexCoord2f(1, 0)
	glVertex2f(x + half_width, y - half_height)
	
	
	glTexCoord2f(1, 1)
	glVertex2f(x + half_width, y + half_height)
	
	
	glTexCoord2f(0, 1)
	glVertex2f(x - half_width, y + half_height)
}

Bullet :: struct {
	entity: u64
	particle_system: u64
	velocity: Vector2
}

create_bullet :: (x: f32, y: f32) {
	bullet: Bullet = --

	entity: Entity
	
	//entity.flags = Entity.Flags.DRAW_RECTANGLE entity.color = make_vector4(1, 0, 1, 1)
	entity.x = x
	entity.y = y
	entity.width = 10
	entity.height = 40
	
	particles: Particle_System
	
	bullet.entity = add_entity(*entity)
	
	particles.relative = bullet.entity
	particles.x = 0
	particles.y = entity.height * 0.5
	particles.texture_handle = 0
	particles.spawn_rate = 1000
	particles.spawn_lifetime = 0.06
	particles.spawn_color = make_vector4(0.45, 0.45, 0.45, 1)
	particles.spawn_radius = 4
	particles.spawn_size = 4
	particles.spawn_mean_velocity = make_vector2(0, -600)
	particles.spawn_velocity_range = make_vector2(0, 200)
	particles.active = true
	
	bullet.particle_system = add_particle_system(*particles)
	bullet.velocity = make_vector2(0, BULLET_SPEED)
	
	array_add_generic(cast() *bullets, *bullet, size_of(Bullet))
}


entities: [..]Entity
particle_systems: [..]Particle_System
bullets: [..]Bullet

FIRE_COOLDOWN :: 0.3

time_to_fire: f32 = 0

_main :: () {
	rng = create_random(1, 1)
/*
	for get_strings() {
		//if it_index {
			print_string(it)
			print_string(" ")
		//}
	}
	*/
	
	null_entity: Entity
	
	add_entity(*null_entity)
	
	performance_counter_frequency: s64
	
	QueryPerformanceFrequency(*performance_counter_frequency)
	
	counter_scale = 1.0 / cast(f32) performance_counter_frequency
	
	startup_info: STARTUPINFOW
	
	GetStartupInfoW(*startup_info)
	
	show_command: u16 = SW_SHOWDEFAULT
	
	if (startup_info.dwFlags & STARTF_USESHOWWINDOW) {
		show_command = startup_info.wShowWindow
	}
	
	instance := GetModuleHandleW(null)
	
	class_name := create_wide_string("Window Class")
	window_class: WNDCLASSW
	
	window_class.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW
	window_class.lpfnWndProc = (hwnd: HWND, uMsg: MSG.Message, wParam: u64, lParam: s64) -> s64 {
		VK_SPACE :: 0x20
		VK_LEFT :: 0x25
		VK_RIGHT :: 0x27
		VK_SHIFT :: 0x10
	
		if uMsg == WM_CLOSE {
			DestroyWindow(hwnd)
		} else if uMsg == WM_DESTROY {
			PostQuitMessage(0)
		} else if uMsg == WM_PAINT {
			paint: PAINTSTRUCT = --
			
			dc := BeginPaint(hwnd, *paint)
			EndPaint(hwnd, *paint)
		} else if uMsg == WM_SIZE {
			client_rect: RECT = --
			
			GetClientRect(hwnd, *client_rect)
			
			window_width = client_rect.right - client_rect.left
			window_height = client_rect.bottom - client_rect.top
			
			print_u64(cast() window_width)
			print_string("x")
			print_u64(cast() window_height)
			print_string("\n----------\n")
			
		} else if uMsg == WM_KEYDOWN {
			if wParam == VK_LEFT
				left_is_down = true
			else if wParam == VK_RIGHT
				right_is_down = true
			else if wParam == VK_SPACE
				space_is_down = true
			else if wParam == VK_SHIFT
				shift_is_down = true
				
		} else if uMsg == WM_KEYUP {
			if wParam == VK_LEFT
				left_is_down = false
			else if wParam == VK_RIGHT
				right_is_down = false
			else if wParam == VK_SPACE
				space_is_down = false
			else if wParam == VK_SHIFT
				shift_is_down = false
				
		} else {
			return DefWindowProcW(hwnd, uMsg, wParam, lParam)
		}
		
		return 0
	}
	window_class.hInstance = instance
	window_class.lpszClassName = class_name
	window_class.hbrBackground = GetStockObject(BLACK_BRUSH)
	
	
	if RegisterClassW(*window_class) == 0 {
		print_string("Failed to register window class\n")
		print_string(u64_to_string(GetLastError()))
		return;
	}
	
	
	window_style := WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MAXIMIZEBOX
	
	window_rect: RECT
	
	window_rect.top = 0
	window_rect.bottom = window_height
	window_rect.left = 0
	window_rect.right = window_width
	
	AdjustWindowRectEx(*window_rect, window_style ^ WS_OVERLAPPED | WS_TILED)
	
	window_handle := CreateWindowExW(lpClassName = class_name, lpWindowName = create_wide_string("Test Window"), dwStyle = WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MAXIMIZEBOX, 
		nWidth = window_rect.right - window_rect.left, nHeight = window_rect.bottom - window_rect.top, hInstance = instance)
	
	if window_handle == null {
		print_string("Failed to open window\n")
		print_string(u64_to_string(GetLastError()))
		return;
	}
	
	device_context := GetDC(window_handle)
	
	desired_format: PIXELFORMATDESCRIPTOR
	desired_format.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER
	desired_format.cColorBits = 32
	desired_format.cAlphaBits = 8
	desired_format.iLayerType = PFD_MAIN_PLANE
	
	found_format := ChoosePixelFormat(device_context, *desired_format)
	
	if found_format == 0 {
		print_string("Could not find a pixel format\n")
		return;
	}
	
	used_format: PIXELFORMATDESCRIPTOR
	
	if !SetPixelFormat(device_context, found_format, *used_format) {
		print_string("Failed to set pixel format")
		return;
	}
	
	
	gl_context := wglCreateContext(device_context)
	
	if !gl_context {
		print_string("Failed to create gl context")
		return;
	}
	
	wglMakeCurrent(device_context, gl_context)
	
	
	load_gl_extensions()
	wglSwapIntervalEXT(1)
	
	player_index: u64
	
	
	glEnable(GL_TEXTURE_2D)
	texture := load_image("Invaders/Spaceship.bmp")
	{	
		entity: Entity = --
	
		entity.x = cast(f32) window_width * 0.5
		entity.y = 150
		entity.width = 128
		entity.height = 128
		entity.flags = Entity.Flags.DRAW_RECTANGLE
		entity.texture_handle = texture
		entity.color = make_vector4(1, 1, 1, 1)
	
		player_index = add_entity(*entity)
	}
	
	left_particles: u64
	right_particles: u64
	
	{
		particle_system: Particle_System
		
		particle_system.relative = player_index
		particle_system.x = -20
		particle_system.y = 0
		particle_system.spawn_rate = 3000
		particle_system.spawn_size = 4
		particle_system.spawn_radius = 5
		particle_system.spawn_mean_velocity = make_vector2(-240, 0)
		particle_system.spawn_velocity_range = make_vector2(-120, 60)
		particle_system.spawn_lifetime = 0.25
		particle_system.spawn_color = make_vector4(0.9, 0.5, 0.07, 1)
		
		left_particles = add_particle_system(*particle_system)
	}

	{
		particle_system: Particle_System
		
		particle_system.relative = player_index
		particle_system.x = 20
		particle_system.y = 0
		particle_system.spawn_rate = 3000
		particle_system.spawn_size = 4
		particle_system.spawn_radius = 5
		particle_system.spawn_mean_velocity = make_vector2(240, 0)
		particle_system.spawn_velocity_range = make_vector2(120, 60)
		particle_system.spawn_lifetime = 0.25
		particle_system.spawn_color = make_vector4(0.9, 0.5, 0.07, 1)
		
		right_particles = add_particle_system(*particle_system)
		
	}
	
	glEnable(GL_BLEND)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	
	ShowWindow(window_handle, cast() show_command)
	
	last_time: s64

	
	QueryPerformanceCounter(*last_time)
	
	while !should_quit {
		message: MSG = --
		
		while PeekMessageW(*message, null) {
			if (message.message == WM_QUIT) {
				should_quit = true
				break
			}
			
			TranslateMessage(*message)
			DispatchMessageW(*message)
		}
		
		current_time: s64
		
		QueryPerformanceCounter(*current_time)
		
		delta := cast() (current_time - last_time) * counter_scale
		
		if shift_is_down
			delta *= 0.05
	
		glViewport(0, 0, window_width, window_height)
		glClearColor(0, 0.1, 0.2, 0)
		glClear(GL_COLOR_BUFFER_BIT)
		
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glOrtho(0, 1280, 0, 720, -5, 5)
		
		player := *entities[player_index]
		
		particle_systems[right_particles].active = left_is_down
		particle_systems[left_particles].active = right_is_down
		
		if left_is_down {
			player.x -= PLAYER_SPEED
		}
		
		if right_is_down {
			player.x += PLAYER_SPEED
		}
		
		if player.x < player.width * 0.5 {
			player.x = player.width * 0.5
		} else if player.x > cast() window_width - player.width * 0.5 {
			player.x = cast() window_width - player.width * 0.5
		}
		
		
		time_to_fire -= delta
		
		if space_is_down && time_to_fire <= 0 {
			time_to_fire += FIRE_COOLDOWN
			
			create_bullet(player.x - 13, player.y + player.height * 0.5 - 30)
			create_bullet(player.x + 13, player.y + player.height * 0.5 - 30)
		}
		
		if time_to_fire < 0
			time_to_fire = 0
		
		
		for * bullet : bullets {
			entity := *entities[bullet.entity]
		
			entity.x += bullet.velocity.x * delta
			entity.y += bullet.velocity.y * delta
			
			if entity.y - entity.height * 0.5 > cast() window_height {
				
				remove_particle_system(bullet.particle_system)
				remove_entity(bullet.entity)
			
				remove
			}
		}
		
		glBlendFunc(GL_ONE, GL_ONE)
		
		for * particle_system: particle_systems {
			if !particle_system.occupied continue;
			
			update_particle_system(particle_system, delta)
			draw_particle_system(particle_system)
		}
		
		
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		
		glBegin(GL_QUADS)
		
		
		for * entity: entities {
			if !entity.occupied continue
		
			if entity.flags & Entity.Flags.DRAW_RECTANGLE {		
				
			
				if entity.texture_handle {
					glBindTexture(GL_TEXTURE_2D, entity.texture_handle)
				
					set_gl_color(entity.color)
					textured_quad(entity)	
				} else {
					glEnd()
					glDisable(GL_TEXTURE_2D)
					
					glBegin(GL_QUADS)
				
					set_gl_color(entity.color)
					untextured_quad(entity)
					
					glEnd()
					glBegin(GL_QUADS)
					
					glEnable(GL_TEXTURE_2D)
				}
			}
		}
		
		// print_u64(cast() (delta * 1000_000))
		// print_string("\n")
		
		glEnd()
		
		SwapBuffers(device_context)
		
		last_time = current_time
	}
	
	glFinish()
	
	wglMakeCurrent(null, null)
	
	wglDeleteContext(gl_context)
	ReleaseDC(window_handle, device_context)
	
	ExitProcess(0)
}
