#load "windows.milo"
#load "gl.milo"
#load "standard.milo"
#load "random/random.milo"	

ListNode :: struct {
	value: string
	next: *ListNode
}

factorial :: (n: u64) -> u64 {
	return 10000000 // Haha! you have resolved the wrong function
}

test :: () {
	a : *u8
	b : *u8

	for a .. b
		factorial(it_index) // dummy code
}

get_strings :: () -> [] string {
	a: [..] string

	array_add_string(*a, "Test1")
	array_add_string(*a, "Test2")

	return a
}

get_linked_strings :: () -> ListNode {
	a: ListNode
	a.value = "LinkedTest1"
	a.next = allocate(size_of(ListNode))
	
	b := a.next
	b.value = "LinkedTest2"
	b.next = null
	
	return a
}

find_string :: (array: []string, s: string) {
	for array {
		if it == s {
			index := u64_to_string(it_index)
			
			print_string(index)
			print_string(": found ")
			print_string(s)
			print_string("\n")
			
			deallocate(cast() index)
			
			break
		}
	} completed {
		print_string("Couldn't find ")
		print_string(s)
		print_string("\n")
	}
	
}

should_quit: bool

window_width: s32 = 1280
window_height: s32 = 720

counter_scale: f32

Bmp_File_Header :: struct #pack {
	header: [2]u8
	file_size: u32
	reserved1: u16
	reserved2: u16
	offset_to_image: u32
}

Bmp_Dib_Header :: struct {
	header_size: u32
	width: s32
	height: s32
	color_plane_count: u16
	bits_per_pixel: u16
	compression_method: u32
	image_size: u32
	horizontal_resolution: u32
	vertical_resolution: u32
	palette_color_count: u32
	important_color_count: u32
	red_mask: u32
	green_mask: u32
	blue_mask: u32
	alpha_mask: u32
	
	BI_RGB       :: 0
	BI_BITFIELDS :: 3
}

load_image :: (filename: string) -> u32 {
	success: bool
	
	file := read_entire_file(filename, *success)
	
	if !success {
		return 0
	}
	
	if file.count < size_of(Bmp_File_Header) + size_of(Bmp_Dib_Header) {
		deallocate(file.data)
		return 0
	}

	file_header := cast(*Bmp_File_Header)file.data
	dib_header := cast(*Bmp_Dib_Header)(file.data + size_of(Bmp_File_Header))
	
	if file_header.header[0] != 'B' || file_header.header[1] != 'M' || file_header.file_size != file.count {
		deallocate(file.data)
		return 0
	}
	
	if dib_header.bits_per_pixel != 32 || 
		dib_header.compression_method != Bmp_Dib_Header.BI_BITFIELDS || 
		dib_header.alpha_mask != 0xFF000000 ||
		dib_header.red_mask   != 0x00FF0000 ||
		dib_header.green_mask != 0x0000FF00 ||
		dib_header.blue_mask  != 0x000000FF ||
		dib_header.height <= 0 {
		
		deallocate(file.data)
		return 0
	}
	
	texture: u32
	
	glGenTextures(1, *texture)
	glBindTexture(GL_TEXTURE_2D, texture)
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, dib_header.width, dib_header.height, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, file.data + file_header.offset_to_image)
	
	deallocate(file.data)
	
	return texture
}

left_is_down:  bool
right_is_down: bool

SPEED :: 15.0

x: f32 = 100.0

Rectangle :: struct {
	x: f32
	y: f32
	width: f32
	height: f32
}

Vector4 :: union {
	using xyzw : struct {
		x: f32
		y: f32
		z: f32
		w: f32
	}
	
	using rgba : struct {
		r: f32
		g: f32
		b: f32
		a: f32
	} = --
	
	elements: [4]f32 = --
}

Entity :: struct {
	using rectangle: Rectangle
	texture_handle: u32
}

Particle_System :: struct {
	x: f32
	y: f32
	texture_handle: u32
	active: bool
}


make_particle_system_active :: () {}

array_add_entity :: (array: *[..]Entity, value: Entity) -> *Entity {
	return array_add_generic(cast() array, *value, size_of(type_of(value)))
}

array_remove_entity_by_pointer :: (array: *[]Entity, value: *Entity) {
	array_remove_generic_by_pointer(cast() array, value, size_of(Entity))
}

set_gl_color :: (color: Vector4) {
	glColor4f(color.r, color.g, color.b, color.a)
}

_main :: () {
/*
	for get_strings() {
		//if it_index {
			print_string(it)
			print_string(" ")
		//}
	}
	*/
	
	entities: [..]Entity
	active_particle_systems: [..]*Particle_System
	all_particles_systems: [..]Particle_System
	
	performance_counter_frequency: s64
	
	QueryPerformanceFrequency(*performance_counter_frequency)
	
	counter_scale = 1.0 / cast(f32) performance_counter_frequency
	
	startup_info: STARTUPINFOW
	
	GetStartupInfoW(*startup_info)
	
	show_command: u16 = SW_SHOWDEFAULT
	
	if (startup_info.dwFlags & STARTF_USESHOWWINDOW) {
		show_command = startup_info.wShowWindow
	}
	
	instance := GetModuleHandleW(null)
	
	class_name := create_wide_string("Window Class")
	window_class: WNDCLASSW
	
	window_class.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW
	window_class.lpfnWndProc = (hwnd: HWND, uMsg: u32, wParam: u64, lParam: s64) -> s64 {
		VK_LEFT :: 0x25
		VK_RIGHT :: 0x27
	
		if uMsg == WM_CLOSE {
			DestroyWindow(hwnd)
		} else if uMsg == WM_DESTROY {
			PostQuitMessage(0)
		} else if uMsg == WM_PAINT {
			paint: PAINTSTRUCT = --
			
			dc := BeginPaint(hwnd, *paint)
			EndPaint(hwnd, *paint)
		} else if uMsg == WM_SIZE {
			client_rect: RECT = --
			
			GetClientRect(hwnd, *client_rect)
			
			window_width = client_rect.right - client_rect.left
			window_height = client_rect.bottom - client_rect.top
		} else if uMsg == WM_KEYDOWN {
			if wParam == VK_LEFT
				left_is_down = true
			else if wParam == VK_RIGHT
				right_is_down = true
				
		} else if uMsg == WM_KEYUP {
			if wParam == VK_LEFT
				left_is_down = false
			else if wParam == VK_RIGHT
				right_is_down = false
				
		} else {
			return DefWindowProcW(hwnd, uMsg, wParam, lParam)
		}
		
		return 0
	}
	window_class.hInstance = instance
	window_class.lpszClassName = class_name
	window_class.hbrBackground = GetStockObject(BLACK_BRUSH)
	
	
	if RegisterClassW(*window_class) == 0 {
		print_string("Failed to register window class\n")
		print_string(u64_to_string(GetLastError()))
		return;
	}
	
	
	window_handle := CreateWindowExW(lpClassName = class_name, lpWindowName = create_wide_string("Test Window"), dwStyle = WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME, nWidth = window_width, nHeight = window_height, hInstance = instance)
	
	if window_handle == null {
		print_string("Failed to open window\n")
		print_string(u64_to_string(GetLastError()))
		return;
	}
	
	device_context := GetDC(window_handle)
	
	desired_format: PIXELFORMATDESCRIPTOR
	desired_format.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER
	desired_format.cColorBits = 32
	desired_format.cAlphaBits = 8
	desired_format.iLayerType = PFD_MAIN_PLANE
	
	found_format := ChoosePixelFormat(device_context, *desired_format)
	
	if found_format == 0 {
		print_string("Could not find a pixel format\n")
		return;
	}
	
	used_format: PIXELFORMATDESCRIPTOR
	
	if !SetPixelFormat(device_context, found_format, *used_format) {
		print_string("Failed to set pixel format")
		return;
	}
	
	
	gl_context := wglCreateContext(device_context)
	
	if !gl_context {
		print_string("Failed to create gl context")
		return;
	}
	
	wglMakeCurrent(device_context, gl_context)
	
	
	load_gl_extensions()
	wglSwapIntervalEXT(1)
	
	player: *Entity
	
	
	glEnable(GL_TEXTURE_2D)
	texture := load_image("Invaders/Spaceship.bmp")
	{	
		entity: Entity = --
	
		entity.x = 100
		entity.y = 100
		entity.width = 128
		entity.height = 128
		entity.texture_handle = texture
	
		player = array_add_entity(*entities, entity)
	}
	
	
	
	glEnable(GL_BLEND)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	
	ShowWindow(window_handle, cast() show_command)
	
	last_time: s64

	
	QueryPerformanceCounter(*last_time)
	
	while !should_quit {
		message: MSG = --
		
		while PeekMessageW(*message, null, 0, 0, PM_REMOVE) {
			if (message.message == WM_QUIT) {
				should_quit = true
				break
			}
			
			TranslateMessage(*message)
			DispatchMessageW(*message)
		}
		
		current_time: s64
		
		QueryPerformanceCounter(*current_time)
		
		delta := cast() (current_time - last_time) * counter_scale
	
		glViewport(0, 0, window_width, window_height)
		glClearColor(0, 0.1, 0.2, 0)
		glClear(GL_COLOR_BUFFER_BIT)
		
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glOrtho(0, 1280, 0, 720, -5, 5)
		
		glBegin(GL_QUADS)
		
		
		for entity: entities {
			glBindTexture(GL_TEXTURE_2D, player.texture_handle)
		
			glTexCoord2f(0, 0)
			glVertex2f(entity.x, entity.y)
			
			
			glTexCoord2f(1, 0)
			glVertex2f(entity.x + entity.width, entity.y)
			
			
			glTexCoord2f(1, 1)
			glVertex2f(entity.x + entity.width, entity.y + entity.height)
			
			
			glTexCoord2f(0, 1)
			glVertex2f(entity.x, entity.y + entity.height)
		}
		
		if left_is_down
			player.x -= SPEED
		else if right_is_down
			player.x += SPEED
		
		glEnd()
		
		SwapBuffers(device_context)
		
		last_time = current_time
	}
	
	wglDeleteContext(gl_context)
	ReleaseDC(window_handle, device_context)
	
	ExitProcess(0)
}

factorial2 :: (n: u64) -> u64 {
	total: u64 = 1
	
	for 2 .. n + 1 total *= it
	
	return total
}
