#load "windows.milo"
#load "gl.milo"
#load "standard.milo"
#load "random/random.milo"
#load "bitmap.milo"
#load "math.milo"

should_quit: bool

window_width: s32 = 1280
window_height: s32 = 720

counter_scale: f32

load_image :: (filename: string) -> u32 {	
	file, success := read_entire_file(filename)
	
	if !success {
		print("Failed to load image ")
		print(filename)
		print("\n")
		return 0
	}
	
	if file.count < size_of(Bmp_File_Header) + size_of(Bmp_Dib_Header) {
		deallocate(file.data)
		return 0
	}

	file_header := cast(*Bmp_File_Header)file.data
	dib_header := cast(*Bmp_Dib_Header)(file.data + size_of(Bmp_File_Header))
	
	if file_header.header != Bmp_File_Header.EXPECTED_HEADER || file_header.file_size != file.count {
		deallocate(file.data)
		return 0
	}
	
	if dib_header.bits_per_pixel != 32 || 
		dib_header.compression_method != .BI_BITFIELDS || 
		dib_header.alpha_mask != 0xFF000000 ||
		dib_header.red_mask   != 0x00FF0000 ||
		dib_header.green_mask != 0x0000FF00 ||
		dib_header.blue_mask  != 0x000000FF ||
		dib_header.height <= 0 {
		
		deallocate(file.data)
		return 0
	}
	
	texture: u32
	
	glGenTextures(1, *texture)
	glBindTexture(GL_TEXTURE_2D, texture)
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, dib_header.width, dib_header.height, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, file.data + file_header.offset_to_image)
	
	deallocate(file.data)
	
	return texture
}

left_is_down:  bool
right_is_down: bool
space_is_down: bool
shift_is_down: bool

PLAYER_SPEED :: 600.0
BULLET_SPEED :: 400.0

ENEMY_BULLET_SPEED :: 250.0

x: f32 = 100.0

Rectangle :: struct {
	x: f32
	y: f32
	width: f32
	height: f32
}

Entity :: struct {
	using rectangle: Rectangle
	
	Flags :: enum_flags u64 {
		DRAW_RECTANGLE
	}
	
	color: Vector4
	
	flags: Flags
	texture_handle: u32
	
	occupied: bool
}



Enemy :: struct {
	entity: u64
	cooldown: f32
	
	State :: enum u8 {
		LEFT
		RIGHT
		DEAD
	}
	
	state := State.LEFT
}

Particle :: struct {
	using location: Rectangle
	location_step: Rectangle
	current_color: Vector4
	color_step: Vector4
	lifetime: f32
}

Particle_System :: struct {

	relative: u64
	x: f32
	y: f32
	texture_handle: u32
	active: bool
	occupied: bool
	
	Mode :: enum u8 {
		NORMAL 
		EXPLOSION
	}
	
	mode := Mode.NORMAL
	
	spawn_progress: f32
	spawn_rate: f32	
	
	spawn_radius: f32
	spawn_size: f32
	spawn_mean_velocity: Vector2
	spawn_velocity_range: Vector2
	spawn_lifetime: f32
	spawn_color: Vector4
	
	particles: [..]Particle
}

rng: Random_State

create_particle :: (using particle_system: *Particle_System) {
	particle: Particle
	
	particle.x = x + random_bilateral(*rng) * spawn_radius
	particle.y = y + random_bilateral(*rng) * spawn_radius
	particle.width = spawn_size
	particle.height = spawn_size
	
	particle.location_step.x = spawn_mean_velocity.x + random_bilateral(*rng) * spawn_velocity_range.x
	particle.location_step.y = spawn_mean_velocity.y + random_bilateral(*rng) * spawn_velocity_range.y

	
	particle.current_color = spawn_color
	
	particle.lifetime = spawn_lifetime
	
	array_add_generic(cast() *particles, *particle, size_of(Particle))
}

create_explosion_particle :: (using particle_system: *Particle_System) {
	particle: Particle
	
	xDir := approximate_sqrt(random_f32(*rng)) * 1.2 - 0.1 // Cheese to deal with the circle approximation
	
	if random_u32(*rng) & 1 {
		xDir = -xDir
	}
	
	yDir := approximate_sqrt(1 - xDir * xDir) * 1.2 - 0.1 // Cheese to deal with the circle approximation
	
	if random_u32(*rng) & 1 {
		yDir = -yDir
	}
	
	spawn_distance := random_f32(*rng) * spawn_radius
	
	particle.x = x + spawn_distance * xDir
	particle.y = y + spawn_distance * yDir
	particle.width = spawn_size
	particle.height = spawn_size
	
	spawn_velocity := spawn_mean_velocity.x + random_bilateral(*rng) * spawn_velocity_range.x
	
	particle.location_step.x = spawn_velocity * xDir
	particle.location_step.y = spawn_velocity * yDir

	
	particle.current_color = spawn_color
	
	particle.lifetime = spawn_lifetime
	
	array_add_generic(cast() *particles, *particle, size_of(Particle))
}

update_particle :: (using particle: *Particle, delta: f32) {
	lifetime -= delta

	
	x      += delta * location_step.x
	y      += delta * location_step.y
	width  += delta * location_step.width
	height += delta * location_step.height
	
	current_color.r += delta * color_step.r
	current_color.g += delta * color_step.g
	current_color.b += delta * color_step.b
	current_color.a += delta * color_step.a
}

update_particle_system :: (using particle_system: *Particle_System, delta: f32) {
	for * particle: particles {
		update_particle(particle, delta)
		
		if particle.lifetime <= 0 {
			remove
			continue
		}
	}
	
	if particle_system.active {
		particle_system.spawn_progress += delta * particle_system.spawn_rate
		
		if particle_system.mode == Particle_System.Mode.NORMAL {
			while particle_system.spawn_progress > 1 {
				particle_system.spawn_progress -= 1
				create_particle(particle_system)
			}
		} else {
			while particle_system.spawn_progress > 1 {
				particle_system.spawn_progress -= 1
				create_explosion_particle(particle_system)
			}
		}
	}
}

draw_particle_system :: (using particle_system: *Particle_System) {
	

	glPushMatrix()
	glTranslatef(entities[relative].x, entities[relative].y, 0)

	if particle_system.texture_handle {
		glBindTexture(GL_TEXTURE_2D, particle_system.texture_handle)
		
		glBegin(GL_QUADS)
		
		for * particle : particles {
			set_gl_color(particle.current_color)
		
			textured_quad(particle)
		}
		
		glEnd()
		
	} else {
		glDisable(GL_TEXTURE_2D)
		
		glBegin(GL_QUADS)
		
		for * particle : particles {
			set_gl_color(particle.current_color)
		
			untextured_quad(particle)
		}
		
		glEnd()
		
		glEnable(GL_TEXTURE_2D)
	}
	
	glPopMatrix()
}

add_entity :: (entity: *Entity) -> u64 {
	for * entities {
		if !it.occupied {
			<<it = <<entity
			it.occupied = true
			
			return it_index
		}
	}
	
	array_add_generic(cast() *entities, entity, size_of(Entity))
	entities[entities.count - 1].occupied = true
	
	return entities.count - 1
}

remove_entity :: (index: u64) {
	entities[index].occupied = false
}

remove_particle_system :: (index: u64) {
	particle_systems[index].occupied = false
}

add_particle_system :: (particle_system: *Particle_System) -> u64 {
	for * particle_systems {
		if !it.occupied {
			<<it = <<particle_system
			it.occupied = true
			
			return it_index
		}
	}
	
	array_add_generic(cast() *particle_systems, particle_system, size_of(Particle_System))
	particle_systems[particle_systems.count - 1].occupied = true
	
	return particle_systems.count - 1
}

set_gl_color :: (color: Vector4) {
	glColor4f(color.r, color.g, color.b, color.a)
}

make_vector2 :: (x: f32, y: f32) -> Vector2 {
	vector: Vector2 = --
	vector.x = x
	vector.y = y
	
	return vector
}

make_vector4 :: (x: f32, y: f32, z: f32, w: f32) -> Vector4 {
	vector: Vector4 = --
	vector.x = x
	vector.y = y
	vector.z = z
	vector.w = w
	
	return vector
}

untextured_quad :: (using rectangle: *Rectangle) {
	half_width := width * 0.5
	half_height := height * 0.5

	glVertex2f(x - half_width, y - half_height)
	
	glVertex2f(x + half_width, y - half_height)
	
	glVertex2f(x + half_width, y + half_height)
	
	glVertex2f(x - half_width, y + half_height)
}

textured_quad :: (using rectangle: *Rectangle) {
	half_width := width * 0.5
	half_height := height * 0.5
	
	glTexCoord2f(0, 0)
	glVertex2f(x - half_width, y - half_height)
	
	
	glTexCoord2f(1, 0)
	glVertex2f(x + half_width, y - half_height)
	
	
	glTexCoord2f(1, 1)
	glVertex2f(x + half_width, y + half_height)
	
	
	glTexCoord2f(0, 1)
	glVertex2f(x - half_width, y + half_height)
}

Bullet :: struct {
	entity: u64
	particle_system: u64
	velocity: Vector2
	enemy: bool
}

Explosion :: struct {
	particle_system: u64
	emission_time: f32 = 0.1
	lifetime: f32 = 0.4
}

create_bullet :: (x: f32, y: f32, vy: f32, color: Vector4, enemy: bool) {
	bullet: Bullet = --

	entity: Entity
	
	//entity.flags = .DRAW_RECTANGLE entity.color = make_vector4(1, 0, 1, 1)
	entity.x = x
	entity.y = y
	entity.width = 10
	entity.height = 0.06 * vy * 2
	
	particles: Particle_System
	
	
	particles.x = 0
	particles.y = entity.height * 0.5
	
	if entity.height < 0 entity.height = -entity.height
	
	bullet.entity = add_entity(*entity)
	
	particles.relative = bullet.entity
	
	particles.texture_handle = 0
	particles.spawn_rate = 1000
	particles.spawn_lifetime = 0.06
	particles.spawn_color = color
	particles.spawn_radius = 4
	particles.spawn_size = 4
	particles.spawn_mean_velocity = make_vector2(0, vy * -1.5)
	particles.spawn_velocity_range = make_vector2(0, vy * 0.5)
	particles.active = true
	
	bullet.particle_system = add_particle_system(*particles)
	bullet.velocity = make_vector2(0, vy)
	bullet.enemy = enemy
	
	array_add_generic(cast() *bullets, *bullet, size_of(Bullet))
}

ENEMY_FIRE_SPEED :: 1.6
ENEMY_SPEED :: 200


create_enemy :: (texture_handle: u32) {
	entity: Entity
	
	entity.flags = .DRAW_RECTANGLE
	entity.x = (random_f32(*rng) + 0.125) * 0.8 * cast()window_width
	entity.y = (random_f32(*rng) + 1.25) * 0.4 * cast() window_height
	entity.width = 96
	entity.height = 96
	
	entity.texture_handle = texture_handle
	entity.color = make_vector4(1, 1, 1, 1)


	enemy: Enemy
	enemy.cooldown = ENEMY_FIRE_SPEED * random_f32(*rng)
	enemy.state = cast() (random_u32(*rng) & 1)
	
	enemy.entity = add_entity(*entity)
	
	array_add_generic(cast() *enemies, *enemy, size_of(Enemy))
}

create_explosion :: (x: f32, y: f32) {
	explosion: Explosion
	
	particles: Particle_System
	
	particles.x = x
	particles.y = y
	
	particles.texture_handle = 0
	particles.spawn_rate = 30000
	particles.spawn_lifetime = 0.3
	particles.spawn_color = make_vector4(0.9, 0.5, 0.07, 1)
	particles.spawn_radius = 30
	particles.spawn_size = 4
	particles.spawn_mean_velocity = make_vector2(300, 0)
	particles.spawn_velocity_range = make_vector2(30, 0)
	particles.active = true
	particles.mode = .EXPLOSION
		
	explosion.particle_system = add_particle_system(*particles)
	
	array_add_generic(cast() *explosions, *explosion, size_of(Explosion))
}


entities: [..]Entity
particle_systems: [..]Particle_System
bullets: [..]Bullet
enemies: [..]Enemy
explosions: [..]Explosion

FIRE_COOLDOWN :: 0.6

time_to_fire: f32 = 0

intersect :: (a: Rectangle, b: Rectangle) -> bool {
	return !(a.x + a.width  * 0.5 < b.x - b.width  * 0.5 || 
			 a.x - a.width  * 0.5 > b.x + b.width  * 0.5 ||
			 a.y + a.height * 0.5 < b.y - b.height * 0.5 ||
			 a.y - a.height * 0.5 > b.y + b.height * 0.5)
}

gl_context: HGLRC

_main :: () {
	rand_seed: s64
	
	QueryPerformanceCounter(*rand_seed)

	rng = create_random(cast(u64) rand_seed, GetTickCount())
	
	null_entity: Entity
	
	add_entity(*null_entity)
	
	performance_counter_frequency: s64
	
	QueryPerformanceFrequency(*performance_counter_frequency)
	
	counter_scale = 1.0 / cast(f32) performance_counter_frequency
	
	startup_info: STARTUPINFOW
	
	GetStartupInfoW(*startup_info)
	
	show_command: u16 = SW_SHOWDEFAULT
	
	if (startup_info.dwFlags & STARTF_USESHOWWINDOW) {
		show_command = startup_info.wShowWindow
	}
	
	instance := GetModuleHandleW(null)
	
	class_name := create_wide_string("Window Class")
	window_class: WNDCLASSW
	
	window_class.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW
	window_class.lpfnWndProc = (hwnd: HWND, uMsg: MSG.Message, wParam: u64, lParam: s64) -> s64 {
		VK_SPACE :: 0x20
		VK_LEFT :: 0x25
		VK_RIGHT :: 0x27
		VK_SHIFT :: 0x10
	
		if uMsg == WM_CLOSE {
			glFinish()
			wglDeleteContext(gl_context)

			DestroyWindow(hwnd)
		} else if uMsg == WM_DESTROY {
			PostQuitMessage(0)
		} else if uMsg == WM_PAINT {
			paint: PAINTSTRUCT = --
			
			dc := BeginPaint(hwnd, *paint)
			EndPaint(hwnd, *paint)
		} else if uMsg == WM_SIZE {
			client_rect: RECT = --
			
			GetClientRect(hwnd, *client_rect)
			
			window_width = client_rect.right - client_rect.left
			window_height = client_rect.bottom - client_rect.top
			
			print(cast() window_width)
			print("x")
			print(cast() window_height)
			print("\n----------\n")
			
		} else if uMsg == WM_KEYDOWN {
			if wParam == VK_LEFT
				left_is_down = true
			else if wParam == VK_RIGHT
				right_is_down = true
			else if wParam == VK_SPACE
				space_is_down = true
			else if wParam == VK_SHIFT
				shift_is_down = true
				
		} else if uMsg == WM_KEYUP {
			if wParam == VK_LEFT
				left_is_down = false
			else if wParam == VK_RIGHT
				right_is_down = false
			else if wParam == VK_SPACE
				space_is_down = false
			else if wParam == VK_SHIFT
				shift_is_down = false
				
		} else {
			return DefWindowProcW(hwnd, uMsg, wParam, lParam)
		}
		
		return 0
	}
	window_class.hInstance = instance
	window_class.lpszClassName = class_name
	window_class.hbrBackground = GetStockObject(BLACK_BRUSH)
	
	
	if RegisterClassW(*window_class) == 0 {
		print("Failed to register window class\n")
		print(GetLastError())
		return
	}
	
	
	window_style := WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MAXIMIZEBOX
	
	window_rect: RECT
	
	window_rect.top = 0
	window_rect.bottom = window_height
	window_rect.left = 0
	window_rect.right = window_width
	
	AdjustWindowRectEx(*window_rect, window_style ^ WS_OVERLAPPED | WS_TILED)
	
	window_handle := CreateWindowExW(lpClassName = class_name, lpWindowName = create_wide_string("Test Window"), dwStyle = WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME ^ WS_MAXIMIZEBOX, 
		nWidth = window_rect.right - window_rect.left, nHeight = window_rect.bottom - window_rect.top, hInstance = instance)
	
	if window_handle == null {
		print("Failed to open window\n")
		print(GetLastError())
		return
	}
	
	device_context := GetDC(window_handle)
	
	desired_format: PIXELFORMATDESCRIPTOR
	desired_format.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER
	desired_format.cColorBits = 32
	desired_format.cAlphaBits = 8
	desired_format.iLayerType = PFD_MAIN_PLANE
	
	found_format := ChoosePixelFormat(device_context, *desired_format)
	
	if found_format == 0 {
		print("Could not find a pixel format\n")
		return
	}
	
	used_format: PIXELFORMATDESCRIPTOR
	
	if !SetPixelFormat(device_context, found_format, *used_format) {
		print("Failed to set pixel format")
		return
	}
	
	
	gl_context = wglCreateContext(device_context)
	
	if !gl_context {
		print("Failed to create gl context")
		return
	}
	
	wglMakeCurrent(device_context, gl_context)
	
	
	load_gl_extensions()
	wglSwapIntervalEXT(1)
	
	player_index: u64

	glEnable(GL_TEXTURE_2D)
	texture := load_image("Invaders/Spaceship.bmp")
	{	
		entity: Entity = --
	
		entity.x = cast(f32) window_width * 0.5
		entity.y = 150
		entity.width = 128
		entity.height = 128
		entity.flags = .DRAW_RECTANGLE
		entity.texture_handle = texture
		entity.color = make_vector4(1, 1, 1, 1)
	
		player_index = add_entity(*entity)
	}
	
	left_particles: u64
	right_particles: u64
	
	{
		particle_system: Particle_System
		
		particle_system.relative = player_index
		particle_system.x = -20
		particle_system.y = 0
		particle_system.spawn_rate = 3000
		particle_system.spawn_size = 4
		particle_system.spawn_radius = 5
		particle_system.spawn_mean_velocity = make_vector2(-240, 0)
		particle_system.spawn_velocity_range = make_vector2(-120, 60)
		particle_system.spawn_lifetime = 0.25
		particle_system.spawn_color = make_vector4(0.9, 0.5, 0.07, 1)
		
		left_particles = add_particle_system(*particle_system)
	}

	{
		particle_system: Particle_System
		
		particle_system.relative = player_index
		particle_system.x = 20
		particle_system.y = 0
		particle_system.spawn_rate = 3000
		particle_system.spawn_size = 4
		particle_system.spawn_radius = 5
		particle_system.spawn_mean_velocity = make_vector2(240, 0)
		particle_system.spawn_velocity_range = make_vector2(120, 60)
		particle_system.spawn_lifetime = 0.25
		particle_system.spawn_color = make_vector4(0.9, 0.5, 0.07, 1)
		
		right_particles = add_particle_system(*particle_system)
		
	}
	
	hex_texture := load_image("Invaders/Hex.bmp")
	
	for 10 create_enemy(hex_texture)
	
	glEnable(GL_BLEND)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	
	ShowWindow(window_handle, cast() show_command)
	
	last_time: s64

	
	QueryPerformanceCounter(*last_time)
	
	dummy_player: u64
	
	while !should_quit {
		message: MSG = --
		
		while PeekMessageW(*message, null) {
			if (message.message == WM_QUIT) {
				should_quit = true
				break
			}
			
			TranslateMessage(*message)
			DispatchMessageW(*message)
		}
		
		current_time: s64
		
		QueryPerformanceCounter(*current_time)
		
		delta := cast() (current_time - last_time) * counter_scale
		
		if shift_is_down
			delta *= 0.05
	
		glViewport(0, 0, window_width, window_height)
		glClearColor(0, 0.1, 0.2, 0)
		glClear(GL_COLOR_BUFFER_BIT)
		
		glMatrixMode(GL_PROJECTION)
		glLoadIdentity()
		glOrtho(0, 1280, 0, 720, -5, 5)
		
		player := *entities[player_index]
		
		if !player_index {
			player = null
		}
		
		if player {
			particle_systems[right_particles].active = left_is_down
			particle_systems[left_particles].active = right_is_down
		
			if left_is_down {
				player.x -= PLAYER_SPEED * delta
			}
			
			if right_is_down {
				player.x += PLAYER_SPEED * delta
			}
			
			if player.x < player.width * 0.5 {
				player.x = player.width * 0.5
			} else if player.x > cast() window_width - player.width * 0.5 {
				player.x = cast() window_width - player.width * 0.5
			}
			
			time_to_fire -= delta
			
			if space_is_down && time_to_fire <= 0 {
				time_to_fire += FIRE_COOLDOWN
				
				create_bullet(player.x - 13, player.y + player.height * 0.5 - 30, BULLET_SPEED, make_vector4(0.45, 0.45, 0.45, 1), enemy = false)
				create_bullet(player.x + 13, player.y + player.height * 0.5 - 30, BULLET_SPEED, make_vector4(0.45, 0.45, 0.45, 1), enemy = false)
			}
			
			if time_to_fire < 0
				time_to_fire = 0
			
		} else {
			particle_systems[right_particles].active = false
			particle_systems[left_particles].active = false
		}
			
		
		for * enemy : enemies {
			entity := *entities[enemy.entity]
			
			enemy.cooldown -= delta
			
			if enemy.state == .LEFT {
				entity.x -= ENEMY_SPEED * delta
			} else if enemy.state == .RIGHT {
				entity.x += ENEMY_SPEED * delta
			} else if enemy.state == .DEAD {
				if enemy.cooldown < 0 {
					remove_entity(enemy.entity)
				
					remove
				}
				
				continue
			}
			
			if entity.x < entity.width * 0.5 {
				entity.x = entity.width * 0.5
				enemy.state = .RIGHT
			} else if entity.x > cast() window_width - entity.width * 0.5 {
				entity.x = cast() window_width - entity.width * 0.5
				enemy.state = .LEFT
			}
			
			
			if enemy.cooldown < 0 {
				enemy.cooldown += ENEMY_FIRE_SPEED
				
				create_bullet(entity.x, entity.y - entity.height * 0.5, -ENEMY_BULLET_SPEED, make_vector4(0.45, 0.15, 0.15, 1), enemy = true)
			}
		}
		
		
		for * bullet : bullets {
			entity := *entities[bullet.entity]
		
			entity.x += bullet.velocity.x * delta
			entity.y += bullet.velocity.y * delta
			
			if entity.y < -0.5 * entity.height || entity.y - entity.height * 0.5 > cast() window_height {
				
				remove_particle_system(bullet.particle_system)
				remove_entity(bullet.entity)
			
				remove
			}
		}
		
		for * enemy : enemies {		
			for * bullet : bullets {
				if !bullet.enemy {
					if (intersect(entities[enemy.entity], entities[bullet.entity])) {
								
						remove_particle_system(bullet.particle_system)
						remove_entity(bullet.entity)
					
						remove;
						
						if enemy.state != .DEAD {
							enemy.state = .DEAD
							enemy.cooldown = 0.05
							
							create_explosion(entities[enemy.entity].x, entities[enemy.entity].y)
						}
					}
				}
			}
		}
		
		if player {
			for * bullet : bullets {
				if bullet.enemy {
					if intersect(player, entities[bullet.entity]) {
						remove_particle_system(bullet.particle_system)
						remove_entity(bullet.entity)
					
						remove;
						
						create_explosion(player.x, player.y)
						
						dummy: Entity
						dummy.x = player.x
						dummy.y = player.y
						dummy.flags = 0
						
						dummy_player = add_entity(*dummy)
						
						particle_systems[left_particles].relative = dummy_player
						particle_systems[right_particles].relative = dummy_player
						
						remove_entity(player_index)
						
						player_index = 0
						
						break
					}
				}
			}
		}
		
		for * explosion : explosions {
			explosion.emission_time -= delta
			explosion.lifetime -= delta
			
			particle_systems[explosion.particle_system].active = explosion.emission_time > 0
			
			if explosion.lifetime <= 0 {
				remove_particle_system(explosion.particle_system)
			
				remove
			}
		}
		
		glBlendFunc(GL_ONE, GL_ONE)
		
		for * particle_system: particle_systems {
			if !particle_system.occupied continue;
			
			update_particle_system(particle_system, delta)
			draw_particle_system(particle_system)
		}
		
		
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		
		for * entity: entities {
			if !entity.occupied continue
		
			if entity.flags & .DRAW_RECTANGLE {		
				
			
				if entity.texture_handle {
					glEnable(GL_TEXTURE_2D)
					glBindTexture(GL_TEXTURE_2D, entity.texture_handle)
					
					glBegin(GL_QUADS)
				
					set_gl_color(entity.color)
					textured_quad(entity)
					
					glEnd()
				} else {
					glDisable(GL_TEXTURE_2D)
					
					glBegin(GL_QUADS)
				
					set_gl_color(entity.color)
					untextured_quad(entity)
					
					glEnd()
				}
			}
		}
		
		if (cast() (delta * 1000_000) > 20_000) {
			print(cast(s64) (delta * 1000_000))
			print("\n")
		}
		
		// print(cast() (delta * 1000_000))
		// print("\n")
		
		SwapBuffers(device_context)
		
		last_time = current_time
	}

	ReleaseDC(window_handle, device_context)
	
	ExitProcess(0)
}
