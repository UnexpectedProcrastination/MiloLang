#load "windows.milo"

copy_string :: (s: string) -> string {
	memory: *u8 = allocate(string_length(s) + 1)
	
	buf := memory
	
	for s {
		<< memory = it
		memory += 1
	}
	
	<< memory = 0
	
	return cast() buf
}

args: []string

ListNode :: struct {
	value: string;
	next: *ListNode;
}

min :: (a: u64, b: u64) -> u64 {
	if a < b 
		return a
	else 
		return b
}

max :: (a: u64, b: u64) -> u64 {
	if a > b 
		return a
	else 
		return b
}

add_string :: (array: *[..] string, value: string) {
	if (array.count >= array.capacity) {
		array.capacity = max(array.count * 2, 4)
		
		array.data = reallocate(array.data, array.capacity * size_of(type_of(value)))
	}
	
	array.data[array.count] = value
	array.count += 1
}

string_length :: (s: string) -> u64 {
	len: u64 = 0
	while s[len] len += 1

	return len
}



print_string :: (s: string) {
	buffer: []u8
	
	buffer.data = cast() s
	buffer.count = string_length(s)

	print_buffer(buffer)
}


parse_command_line :: (cmd: string) -> [] string {
	line := cast(*u8) copy_string(cmd)

	args: [..]string
	
	
	s := cast(*u8) cmd
	
	if ! <<s
		return args
	
	if << s == '"' {
		s += 1
		line += 1
		
		add_string(*args, cast() line)
		
		while << s {
			if << s == '"'
				break;
			
			line += 1
			s += 1
		}
	} else {
		add_string(*args, cast() line)
		
		while << s {
			if << s == ' ' || << s == '\t'
				break;
			
			line += 1
			s += 1
		}
	}
	
	<< line = 0
	
	line += 1
	s += 1
	
	while << s == ' ' || << s == '\t' {
		s += 1
		line += 1
	}
	
	if ! <<s
		return args
		
	add_string(*args, cast() line)
	
	// @Incomplete
	
	return args
}


main :: () -> s32 {
	//args.data = argv
	//args.count = cast(u64) argc
	init_runtime()

	_main()

	return 0
}

get_command_line_arguments :: () -> []string {
	return args
}

factorial :: (n: u64) -> u64 {
	return 10000000 // Haha! you have resolved the wrong function
}

test :: () {
	a : *u8
	b : *u8

	for a .. b
		factorial(it_index) // dummy code
}

get_strings :: () -> [] string {
	a: [..] string

	add_string(*a, "Test1")
	add_string(*a, "Test2")

	return a
}

get_linked_strings :: () -> ListNode {
	a: ListNode
	a.value = "LinkedTest1"
	a.next = allocate(size_of(ListNode))
	
	b := a.next
	b.value = "LinkedTest2"
	b.next = null
	
	return a
}

u64_to_string :: (value: u64) -> string {
	if value == 0 {
		result := cast(*u8) allocate(2)
		result[0] = '0'
		result[1] = 0
		
		return cast() result
	}

	digitCount: u64
	
	remaining := value
	
	while remaining {
		digitCount += 1
		
		remaining /= 10
	}
	
	result := cast(*u8) allocate(digitCount + 1)
	
	result += digitCount;
	
	<<result = 0
	remaining = value
	
	while remaining {
		result -= 1;
		
		<<result = cast() (remaining % 10 + '0')
		remaining /= 10
	}
	
	return cast() result
}

find_string :: (array: []string, s: string) {
	for array {
		if it == s {
			index := u64_to_string(it_index)
			
			print_string(index)
			print_string(": found ")
			print_string(s)
			print_string("\n")
			
			deallocate(cast() index)
			
			break
		}
	} completed {
		print_string("Couldn't find ")
		print_string(s)
		print_string("\n")
	}
	
}


// @Incomplete, only converts ascii to UTF16, not UTF8
create_wide_string :: (s: string) -> *u16 {
	result: *u16 = allocate((string_length(s) + 1) * size_of(u16))
	
	buffer := result
	
	sbuf := cast(*u8) s
	
	while <<sbuf {
		<<buffer = <<sbuf
		buffer += 1
		sbuf += 1
	}
	
	<<buffer = 0
	
	return result
}

should_quit: bool

_main :: () {
/*
	for get_strings() {
		//if it_index {
			print_string(it)
			print_string(" ")
		//}
	}
	*/
	
	startup_info: STARTUPINFOW
	
	GetStartupInfoW(*startup_info)
	
	show_command := SW_SHOWDEFAULT
	
	if (startup_info.dwFlags & STARTF_USESHOWWINDOW) {
		show_command = startup_info.wShowWindow
	}
	
	instance := GetModuleHandleW(null)
	
	class_name := create_wide_string("Window Class")
	window_class: WNDCLASSW
	
	window_class.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW
	window_class.lpfnWndProc = (hwnd: HWND, uMsg: u32, wParam: u64, lParam: s64) -> s64 {
		if uMsg == WM_CLOSE {
			DestroyWindow(hwnd)
			return 0
		} else if uMsg == WM_DESTROY {
			PostQuitMessage(0)
			return 0
		} else if uMsg == WM_PAINT {
			paint: PAINTSTRUCT = --
			device_context := BeginPaint(hwnd, *paint)
			
			PatBlt(device_context, paint.rcPaint.left, paint.rcPaint.top, paint.rcPaint.right - paint.rcPaint.left, paint.rcPaint.bottom - paint.rcPaint.top, BLACKNESS)
			
			EndPaint(hwnd, *paint)
		} else if uMsg == WM_SIZE {
			return 0
		} else {
			return DefWindowProcW(hwnd, uMsg, wParam, lParam)
		}
	}
	window_class.hInstance = instance
	window_class.lpszClassName = class_name
	window_class.hbrBackground = GetStockObject(BLACK_BRUSH)
	
	
	if RegisterClassW(*window_class) == 0 {
		print_string("Failed to register window class\n")
		print_string(u64_to_string(GetLastError()))
	}
	
	
	window_handle := CreateWindowExW(lpClassName = class_name, lpWindowName = create_wide_string("Test Window"), nWidth = 1280, nHeight = 720, hInstance = instance)
	
	if window_handle == null {
		print_string("Failed to open window\n")
		print_string(u64_to_string(GetLastError()))
		return;
	}
	
	ShowWindow(window_handle, cast() show_command)
	
	while !should_quit {
		message: MSG = --
		result := GetMessageW(*message, null, 0, 0)
		
		if result <= 0 {
			should_quit = true
		} else {
			TranslateMessage(*message)
			DispatchMessageW(*message)
		}
	}
}

factorial2 :: (n: u64) -> u64 {
	total: u64 = 1
	
	for 2 .. n + 1 total *= it
	
	return total
}
