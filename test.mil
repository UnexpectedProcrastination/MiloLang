/*

[]T :: struct {
	buffer: *T
	count: u64
}

[..]T :: struct {
	buffer: *T
	count: u64
	capacity: u64
}

*/


argCount: s32
args: *string

STD_INPUT_HANDLE: u32: 0xFFFF_FFF6 // -10
STD_OUTPUT_HANDLE: u32: 0xFFFF_FFF5 // -11
STD_ERROR_HANDLE: u32: 0xFFFF_FFF4 // -12

GetStdHandle :: (nStdHandle: u32) -> HANDLE #external

HANDLE :: *void
WriteConsoleA :: (hConsoleOutput: HANDLE, lpBuffer: *void, nNumberOfCharactersToWrite: u32, lpNumberOfCharactersWritten: *u32 = null, lpReserved: *void = null) -> bool #external

string_length :: (s: string) -> u64 {
	len: u64 = 0
	while s[len] len += 1

	return len
}

print_string :: (s: string) {
	WriteConsoleA(std_out, cast() s, cast() string_length(s), null, null)
}


std_out: HANDLE

main :: (argc: s32, argv: *string) -> s32 {
	argCount = argc
	args = argv

	std_out = GetStdHandle(STD_OUTPUT_HANDLE)

	_main()

	return 0
}

get_command_line_arguments :: (argc: *s32) -> *string {
	<< argc = argCount
	return args
}

factorial :: (n: u64) -> u64 {
	return 10000000 // Haha! you have resolved the wrong function
}

test :: () {
	a : *u8
	b : *u8

	for a .. b
		factorial(it_index) // dummy code
}

hello := "Hello World!\n"

_main :: () {
	print_string(hello);
}

factorial2 :: (n: u64) -> u64 {
	total: u64 = 1
	
	for 2 .. n + 1 total *= it
	
	return total
}
