/*

[]T :: struct {
	buffer: *T
	count: u64
}

[..]T :: struct {
	buffer: *T
	count: u64
	capacity: u64
}

*/


args: []string

STD_INPUT_HANDLE: u32: 0xFFFF_FFF6 // -10
STD_OUTPUT_HANDLE: u32: 0xFFFF_FFF5 // -11
STD_ERROR_HANDLE: u32: 0xFFFF_FFF4 // -12

GetStdHandle :: (nStdHandle: u32) -> HANDLE #external

HANDLE :: *void
WriteConsoleA :: (hConsoleOutput: HANDLE, lpBuffer: *void, nNumberOfCharactersToWrite: u32, lpNumberOfCharactersWritten: *u32 = null, lpReserved: *void = null) -> bool #external

process_heap: HANDLE


GetCommandLineA :: () -> string #external
GetProcessHeap :: () -> HANDLE #external

HeapAlloc :: (hHeap: HANDLE, dwFlags: u32, dwBytes: u64) -> *void #external
HeapReAlloc :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void, dwBytes: u64) -> *void #external
HeapFree :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void) -> bool #external

allocate :: (size: u64) -> *void {
	return HeapAlloc(process_heap, 0, size)
}

reallocate :: (block: *void, size: u64) -> *void {
	if size == 0 {
		deallocate(block)
		return null
	} else if block == null
		return allocate(size)
	else
		return HeapReAlloc(process_heap, 0, size)
}

deallocate :: (block *void) {
	HeapFree(process_heap, 0, block)
}

min :: (a: u64, b: u64) -> u64 {
	if a < b 
		return a
	else 
		return b
}

max :: (a: u64, b: u64) -> u64 {
	if a > b 
		return a
	else 
		return b
}

add_string :: (array: *[..] string, string value) {
	
}

string_length :: (s: string) -> u64 {
	len: u64 = 0
	while s[len] len += 1

	return len
}

print_string :: (s: string) {
	WriteConsoleA(std_out, cast() s, cast() string_length(s), null, null)
}


std_out: HANDLE

main :: (argc: s32, argv: *string) -> s32 {
	argsPtr := cast(*u64) *args

	argsPtr[0] = cast(u64) argv
	argsPtr[1] = cast(u64) argc

	std_out = GetStdHandle(STD_OUTPUT_HANDLE)

	_main()

	return 0
}

get_command_line_arguments :: () -> []string {
	return args
}

factorial :: (n: u64) -> u64 {
	return 10000000 // Haha! you have resolved the wrong function
}

test :: () {
	a : *u8
	b : *u8

	for a .. b
		factorial(it_index) // dummy code
}

get_strings :: () -> [2] string {
	a : [2] string

	a[0] = "Test1"
	a[1] = "Test2"

	return a
}

_main :: () {
	

	for get_command_line_arguments() {
		if it_index {
			print_string(it)
			print_string(" ")
		}
	}
}

factorial2 :: (n: u64) -> u64 {
	total: u64 = 1
	
	for 2 .. n + 1 total *= it
	
	return total
}
