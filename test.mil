/*

[]T :: struct {
	buffer: *T
	count: u64
}

[..]T :: struct {
	buffer: *T
	count: u64
	capacity: u64
}

*/

copy_string :: (s: string) -> string {
	memory: *u8 = allocate(string_length(s) + 1)
	
	buf := memory
	
	for s {
		<< memory = it
		memory += 1
	}
	
	<< memory = 0
	
	return cast() buf
}

args: []string

STD_INPUT_HANDLE: u32: cast() -10
STD_OUTPUT_HANDLE: u32: cast() -11
STD_ERROR_HANDLE: u32: cast() -12

GetStdHandle :: (nStdHandle: u32) -> HANDLE #external

HANDLE :: *void
WriteConsoleA :: (hConsoleOutput: HANDLE, lpBuffer: *void, nNumberOfCharactersToWrite: u32, lpNumberOfCharactersWritten: *u32 = null, lpReserved: *void = null) -> bool #external

process_heap: HANDLE


GetCommandLineA :: () -> string #external
GetProcessHeap :: () -> HANDLE #external

HeapAlloc :: (hHeap: HANDLE, dwFlags: u32, dwBytes: u64) -> *void #external
HeapReAlloc :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void, dwBytes: u64) -> *void #external
HeapFree :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void) -> bool #external

allocate :: (size: u64) -> *void {
	return HeapAlloc(process_heap, 0, size)
}

reallocate :: (block: *void, size: u64) -> *void {
	if block == null
		return allocate(size)
	else
		return HeapReAlloc(process_heap, 0, block, size)
}

deallocate :: (block: *void) {
	HeapFree(process_heap, 0, block)
}

ListNode :: struct {
	value: string;
	next: *ListNode;
}

min :: (a: u64, b: u64) -> u64 {
	if a < b 
		return a
	else 
		return b
}

max :: (a: u64, b: u64) -> u64 {
	if a > b 
		return a
	else 
		return b
}

add_string :: (array: *[..] string, value: string) {
	if (array.count >= array.capacity) {
		array.capacity = max(array.count * 2, 4)
		
		array.data = reallocate(array.data, array.capacity * size_of(type_of(value)))
	}
	
	array.data[array.count] = value
	array.count += 1
}

string_length :: (s: string) -> u64 {
	len: u64 = 0
	while s[len] len += 1

	return len
}

print_string :: (s: string) {
	WriteConsoleA(std_out, cast() s, cast() string_length(s), null, null)
}


std_out: HANDLE


parse_command_line :: (cmd: string) -> [] string {
	line := cast(*u8) copy_string(cmd)

	args: [..]string
	
	
	s := cast(*u8) cmd
	
	if ! <<s
		return args
	
	if << s == '"' {
		s += 1
		line += 1
		
		add_string(*args, cast() line)
		
		while << s {
			if << s == '"'
				break;
			
			line += 1
			s += 1
		}
	} else {
		add_string(*args, cast() line)
		
		while << s {
			if << s == ' ' || << s == '\t'
				break;
			
			line += 1
			s += 1
		}
	}
	
	<< line = 0
	
	line += 1
	s += 1
	
	while << s == ' ' || << s == '\t' {
		s += 1
		line += 1
	}
	
	if ! <<s
		return args
		
	add_string(*args, cast() line)
	
	// @Incomplete
	
	return args
}


main :: () -> s32 {
	//args.data = argv
	//args.count = cast(u64) argc

	process_heap = GetProcessHeap()
	std_out = GetStdHandle(STD_OUTPUT_HANDLE)

	_main()

	return 0
}

get_command_line_arguments :: () -> []string {
	return args
}

factorial :: (n: u64) -> u64 {
	return 10000000 // Haha! you have resolved the wrong function
}

test :: () {
	a : *u8
	b : *u8

	for a .. b
		factorial(it_index) // dummy code
}

get_strings :: () -> [] string {
	a: [..] string

	add_string(*a, "Test1")
	add_string(*a, "Test2")

	return a
}

get_linked_strings :: () -> ListNode {
	a: ListNode;
	a.value = "LinkedTest1";
	a.next = allocate(size_of(ListNode));
	
	b := a.next;
	b.value = "LinkedTest2";
	b.next = null;
	
	return a;
}

_main :: () {
/*
	for get_strings() {
		//if it_index {
			print_string(it)
			print_string(" ")
		//}
	}
	*/
	
	list := get_linked_strings();
	
	while true {
		print_string(list.value);
		print_string(" ");
		
		if list.next == null
			break;
			
		list = <<list.next;
	}
}

factorial2 :: (n: u64) -> u64 {
	total: u64 = 1
	
	for 2 .. n + 1 total *= it
	
	return total
}
