string_ :: *u8

argCount: s32
args: *string_

main :: (argc: s32, argv: *string_) -> s32 {
	argCount = argc
	args = argv

	_main()

	return 0
}

get_command_line_arguments :: (argc: *s32) -> *string_ {
	<< argc = argCount
	return args
}

factorial :: (n: u64) -> u64 {
	return 10000000 // Haha! you have resolved the wrong function
}

test :: () {
	a : *void
	b : *void

	for a .. b
		factorial(it_index) // dummy code
}

_main :: () {
/* This should cause an error now
	factorial :: (n: u64) -> u64 {
		return << cast(*u64) null // Uh oh, you have resolved the wrong function
	}
*/

	{
		// Put in a hack to make sure we can use a declaration recursively in functions
		// @Solution I think the way we do this is to allow out of order declaration of constants in local scopes
		factorial :: (n: u64) -> u64 {
			if n <= 1
				return 1
			return n * factorial(n - 1)
		}
	}

	// but we can't use it recursively elsewhere
	// @Solution This should be a circular dependency error then for type
	//error : u64 : error

	argCount: s32 = --
	args := get_command_line_arguments(*argCount)

	factorial(cast() argCount)
}

factorial2 :: (n: u64) -> u64 {
	total: u64 = 1
	
	for 2 .. n + 1 total *= it
	
	return total
}
