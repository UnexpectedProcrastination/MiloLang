enums
 - Do we allow signed enums?
 - array of names
 - array of values
 - is_indexable -> do the enum values go in order from 0..N, so the names array can be indexed directly with the enum value
 - largest_value
 - smallest_value 

// Maybe this if fine
currently this doesn't do what you'd expect
	A :: struct {
		a := "A"
	}

	B :: struct {
		b := "B"
		using included: A
	}

	print_b :: (b: *B) {
		print_string(b.b)
	}

	main :: () {
		b: B
		a : *A = *b
		
		// ...
		
		print_b(cast(*B) a) // Prints "A" because a cast from 'base class' to 'sub class' just does a pointer conversion instead of paying attention to the using
	}
	
Make it a compile time error to out of bounds index a static array if the index is a constant
 - Compile time error for constant negative index of normal and dynamic arrays?
 - Compile time error for things that are an array literal of normal or dynamic type
 
Compile option for runtime checking
 - Array bounds checking
 - Cast bounds checking
 - 

ABI/calling convention
 - multiple return values
 - varargs (represent with arrays?)
 - arguments by value are immutable?
 

multiple return values
 - Named return values
 - Return values are declarations
 - Make #must work with multiple returns
 - ABI
   - 
 
varargs
 - 
 
string representation
 - same memory as []u8 but a different type (allow casting?)
   - different types convey intent
   - can have separate display behaviour (when printing and debugging)
 - string literals implicitly convert to C-strings
   - is it worth having implict conversion to utf16 C-strings (windows wide strings) and utf32 C-strings
   
 - utf16 and utf32 string types?
 
error if non-void functions don't have all control paths return

function overloading

performance
 - Profile TypeTable.cpp
 - Call infer fewer times - go through fewer InferJobs each iteration 
   - graph theory?
 - More fast paths for trival type inference
 - Allocator in Infer.cpp, TypeTable.cpp
 - Ensure sufficient space to write all instructions in coff writer so we don't do a bounds check for each byte written
 - Multithread ir generator
 - Multithread coff writer?
 - Multithread parser and lexer - Write obj faster (somehow)
 - Multithread type inference (nightmare nightmare nightmare)
 

#if
 - Syntax of both blocks checked, type checking only happens for chosen block

defer

switch if
 - #complete

runtime manipulation of type values
 - ==, !=
 - get runtime type info (shouldn't require a constant type)
 
debug info
 - show locals
 - emit struct information
 - emit S_UDT for constant type declarations
 - emit constants
 - deal with the local function nightmare
 - do we have to do some natvis embedding bs to get arrays to show correctly in the debugger
 
improve external function interface
 - don't hardcode lib files to link with
 - separate function types for external functions (so our calling convention doesn't need to be C-compatible)
 
change completed keyword (its ugly and completed is something you want to call an identifer)
 
llvm

runtime type information
 - size, struct members, signedness, arguments, pointer to, etc.
 
box type
 - struct containing pointer to value and type information
 
predefined constant variables
 - BUILD_WINDOWS, BUILD_LINUX, etc...
 
#tag
 - Mark an if statement as #tag, if a struct member is compared to a type, the struct will imlicitly convert to that type in the if body
 - Make it work using box type?
 - Work with switch if
 
utf8 identifiers?

run ir at compile time

