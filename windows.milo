HINSTANCE :: *struct {
	unused: s32
}


HMODULE :: HINSTANCE

HWND :: *struct {
	unused: s32
}

HICON :: *struct {
	unused: s32
}

HCURSOR :: HICON

HBRUSH :: *struct {
	unused: s32
}

HMENU :: *struct {
	unused: s32
}

HDC :: *struct {
	unused: s32
}

HGLRC :: *struct {
	unused: s32
}
RECT :: struct {
	left: s32
	top: s32
	right: s32
	bottom: s32
}

HANDLE :: *void
HGDIOBJ :: *void

WNDPROC :: (hwnd: HWND, uMsg: u32, wParam: u64, lParam: s64) -> s64
DefWindowProcW :: (hWnd: HWND, Msg: u32, wParam: u64, lParam: s64) -> s64 #external

WNDCLASSW :: struct {
	style: u32
	lpfnWndProc: WNDPROC
	cbClsExtra: s32
	cbWndExtra: s32
	hInstance: HINSTANCE
	hIcon: HICON
	hCursor: HCURSOR
	hbrBackground: HBRUSH
	lpszMenuName: *u16
	lpszClassName: *u16
}

STARTUPINFOW :: struct {
	cb: u32
	lpReserved: *u16
	lpDesktop: *u16
	lpTitle: *u16
	dwX: u32
	dwY: u32
	dwXSize: u32
	dwYSize: u32
	dwXCountChars: u32
	dwYCountChars: u32
	dwFillAttribute: u32
	dwFlags: u32
	wShowWindow: u16
	cbReserved2: u16
	lpReserved2: *u8
	hStdInput: HANDLE
	hStdOutput: HANDLE
	hStdError: HANDLE
}

WS_OVERLAPPED   :: 0x0000_0000
WS_POPUP        :: 0x8000_0000
WS_CHILD        :: 0x4000_0000
WS_MINIMIZE     :: 0x2000_0000
WS_VISIBLE      :: 0x1000_0000
WS_DISABLED     :: 0x0800_0000
WS_CLIPSIBLINGS :: 0x0400_0000
WS_CLIPCHILDREN :: 0x0200_0000
WS_MAXIMIZE     :: 0x0100_0000
WS_CAPTION      :: 0x00C0_0000 // WS_BORDER | WS_DLGFRAME
WS_BORDER       :: 0x0080_0000
WS_DLGFRAME     :: 0x0040_0000
WS_VSCROLL      :: 0x0020_0000
WS_HSCROLL      :: 0x0010_0000
WS_SYSMENU      :: 0x0008_0000
WS_THICKFRAME   :: 0x0004_0000
WS_GROUP        :: 0x0002_0000
WS_TABSTOP      :: 0x0001_0000

WS_MINIMIZEBOX  :: 0x0002_0000
WS_MAXIMIZEBOX  :: 0x0001_0000

WS_TILED :: WS_OVERLAPPED
WS_ICONIC :: WS_MINIMIZE
WS_SIZEBOX :: WS_THICKFRAME
WS_TILEDWINDOW :: WS_OVERLAPPEDWINDOW

WS_OVERLAPPEDWINDOW :: 0x00CF_0000 // WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX

WS_POPUPWINDOW :: 0x8088_0000 // WS_POPUP | WS_BORDER | WS_SYSMENU

WS_CHILDWINDOW :: WS_CHILD

WS_EX_DLGMODALFRAME       :: 0x0000_0001
WS_EX_NOPARENTNOTIFY      :: 0x0000_0004
WS_EX_TOPMOST             :: 0x0000_0008
WS_EX_ACCEPTFILES         :: 0x0000_0010
WS_EX_TRANSPARENT         :: 0x0000_0020
WS_EX_MDICHILD            :: 0x0000_0040
WS_EX_TOOLWINDOW          :: 0x0000_0080
WS_EX_WINDOWEDGE          :: 0x0000_0100
WS_EX_CLIENTEDGE          :: 0x0000_0200
WS_EX_CONTEXTHELP         :: 0x0000_0400
WS_EX_RIGHT               :: 0x0000_1000
WS_EX_LEFT                :: 0x0000_0000
WS_EX_RTLEADING           :: 0x0000_2000
WS_EX_LTLEADING           :: 0x0000_0000
WS_EX_LEFTSCROLLBAR       :: 0x0000_4000
WS_EX_RIGHTSCROLLBAR      :: 0x0000_0000
WS_EX_CONTROLPARENT       :: 0x0001_0000
WS_EX_STATICEDGE          :: 0x0002_0000
WS_EX_APPWINDOW           :: 0x0004_0000
WS_EX_LAYERED             :: 0x0008_0000
WS_EX_NOINHERITLAYOUT     :: 0x0010_0000
WS_EX_NOREDIRECTIONBITMAP :: 0x0020_0000
WS_EX_LAYOUTRTL           :: 0x0200_0000
WS_EX_COMPOSITED          :: 0x0400_0000
WS_EX_NOACTIBE            :: 0x0800_0000

CS_VREDRAW          :: 0x0000_0001
CS_HREDRAW          :: 0x0000_0002
CS_DBLCLKS          :: 0x0000_0008
CS_OWNDC            :: 0x0000_0020
CS_CLASSDC          :: 0x0000_0040
CS_PARENTDC         :: 0x0000_0080
CS_NOCLOSE          :: 0x0000_0200
CS_SAVEBITS         :: 0x0000_0800
CS_BYTEALIGNCLIENT  :: 0x0000_1000
CS_BYTEALIGNWINDOW  :: 0x0000_2000
CS_GLOBALCLASS      :: 0x0000_4000
CS_IME              :: 0x0001_0000
CS_DROPSHADOW       :: 0x0002_0000


WS_EX_OVERLAPPEDWINDOW :: 0x0000_0300 // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
WS_EX_PALETTE_WINDOW   :: 0x0000_0188 // WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST

STARTF_USESHOWWINDOW    :: 0x0000_0001
STARTF_USESIZE          :: 0x0000_0002
STARTF_USEPOSITION      :: 0x0000_0004
STARTF_USECOUNTCHARS    :: 0x0000_0008
STARTF_USEFILLATTRIBUTE :: 0x0000_0010
STARTF_RUNFULLSCREEN    :: 0x0000_0020
STARTF_FORCEONFEEDBACK  :: 0x0000_0040
STARTF_FORCEOFFFEEDBACK :: 0x0000_0080
STARTF_USESTDHANDLES    :: 0x0000_0100

SW_HIDE:            u16: 0
SW_SHOWNORMAL:      u16: 1
SW_NORMAL:          u16: 1
SW_SHOWMINIMIZED:   u16: 2
SW_SHOWMAXIMIZED:   u16: 3
SW_MAXIMIZE:        u16: 3
SW_SHOWNOACTIVATE:  u16: 4
SW_SHOW:            u16: 5
SW_MINIMIZE:        u16: 6
SW_SHOWMINNOACTIVE: u16: 7
SW_SHOWNA:          u16: 8
SW_RESTORE:         u16: 9
SW_SHOWDEFAULT:     u16: 10
SW_FORCEMINIMIZE:   u16: 11
SW_MAX:             u16: 11

POINT :: struct {
	x: s32
	y: s32
}

MSG :: struct {
	hwnd: HWND
	message: u32
	wParam: u64
	lParam: s64
	time: u32
	pt: POINT
}


CW_USEDEFAULT :: cast(s32) 0x80000000

GetStartupInfoW :: (lpStartupInfo: *STARTUPINFOW) #external

CreateWindowExW :: (dwExStyle: u32 = 0, lpClassName: *u16, lpWindowName: *u16, dwStyle: u32 = WS_OVERLAPPEDWINDOW, X: s32 = CW_USEDEFAULT, Y: s32 = CW_USEDEFAULT, nWidth: s32, nHeight: s32, hWndParent: HWND = null, hMenu: HMENU = null, hInstance: HINSTANCE, lpParam: *void = null) -> HWND #external

PAINTSTRUCT :: struct {
	hdc: HDC
	fErase: s32
	rcPaint: RECT
	fRestore: s32
	fIncUpdate: s32
	rgbReserved: [32]u8
}

BeginPaint :: (hWnd: HWND, lpPaint: *PAINTSTRUCT) -> HDC #external
EndPaint :: (hWnd: HWND, lpPaint: *PAINTSTRUCT) -> s32 #external

PatBlt :: (hdc: HDC, x: s32, y: s32, w: s32, h: s32, rop: u32) -> s32 #external

BLACKNESS :: 0x0000_0042
WHITENESS :: 0x00FF_0062

GetStockObject :: (i: s32) -> HGDIOBJ #external

WHITE_BRUSH:         s32: 0
LTGRAY_BRUSH:        s32: 1
GRAY_BRUSH:          s32: 2
DKGRAY_BRUSH:        s32: 3
BLACK_BRUSH:         s32: 4
NULL_BRUSH:          s32: 5
HOLLOW_BRUSH:        s32: NULL_BRUSH
WHITE_PEN:           s32: 6
BLACK_PEN:           s32: 7
NULL_PEN:            s32: 8
OEM_FIXED_FONT:      s32: 10
ANSI_FIXED_FONT:     s32: 11
ANSI_VAR_FONT:       s32: 12
SYSTEM_FONT:         s32: 13
DEVICE_DEFAULT_FONT: s32: 14
DEFAULT_PALETTE:     s32: 15
SYSTEM_FIXED_FONT:   s32: 16
DEFAULT_GUI_FONT:    s32: 17
DC_BRUSH:            s32: 18
DC_PEN:              s32: 19

GetClientRect :: (hWnd: HWND, lpRect: *RECT) -> s32 #external

STD_INPUT_HANDLE  :: cast(u32) -10
STD_OUTPUT_HANDLE :: cast(u32) -11
STD_ERROR_HANDLE  :: cast(u32) -12

GetLastError :: () -> u32 #external

GetStdHandle :: (nStdHandle: u32) -> HANDLE #external
GetModuleHandleW :: (lpModuleName: *u8) -> HMODULE #external

WriteConsoleA :: (hConsoleOutput: HANDLE, lpBuffer: *void, nNumberOfCharactersToWrite: u32, lpNumberOfCharactersWritten: *u32 = null, lpReserved: *void = null) -> s32 #external

RegisterClassW :: (lpWndClass: *WNDCLASSW) -> u16 #external

ShowWindow :: (hWnd: HWND, nCmdShow: s32) -> s32 #external

GetMessageW :: (lpMsg: *MSG, hWnd: HWND,  wMsgFilterMin: u32, wMsgFilterMax: u32) -> s32 #external
PeekMessageW :: (lpMsg: *MSG, hWnd: HWND,  wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMessage: u32) -> s32 #externalTranslateMessage :: (lpMsg: *MSG) -> s32 #external
DispatchMessageW :: (lpMsg: *MSG) -> s32 #external

GetDC :: (hWnd: HWND) -> HDC #external
ReleaseDC :: (hWnd: HWND, hdc: HDC) -> s32 #external
DeleteDC :: (hdc: HDC) -> s32 #external

WM_NULL            :: 0x0000
WM_CREATE          :: 0x0001
WM_DESTROY         :: 0x0002
WM_MOVE            :: 0x0003
WM_SIZE            :: 0x0005
WM_ACTIVATE        :: 0x0006
WM_SETFOCUS        :: 0x0007
WM_KILLFOCUES      :: 0x0008
WM_ENABLE          :: 0x000A
WM_SETREDRAW       :: 0x000B
WM_SETTEXT         :: 0x000C
WM_GETTEXT         :: 0x000D
WM_GETTEXTLENGTH   :: 0x000E
WM_PAINT           :: 0x000F
WM_CLOSE           :: 0x0010
WM_QUERYENDSESSION :: 0x0011
WM_QUIT            :: 0x0012
WM_QUERYOPEN       :: 0x0013
WM_ERASEBKGND      :: 0x0014
WM_SYSCOLORCHANGE  :: 0x0015
WM_ENDSESSION      :: 0x0016
WM_SHOWWINDOW      :: 0x0018
WM_WININICHANGE    :: 0x001A
WM_DEVMODECHANGE   :: 0x001B
WM_ACTIVATEAPP     :: 0x001C
WM_FONTCHANGE      :: 0x001D
WM_TIMECHANGE      :: 0x001E
WM_CANCELMODE      :: 0x001F
WM_SETCURSOR       :: 0x0020
WM_MOUSEACTIVATE   :: 0x0021
WM_CHILDACTIVATE   :: 0x0022
WM_QUEUESYNC       :: 0x0023
WM_GETMINMAXINFO   :: 0x0024

DestroyWindow :: (hWnd: HWND) -> s32 #external
PostQuitMessage :: (nExitCode: s32) #external

PM_NOREMOVE :: 0
PM_REMOVE   :: 1
PM_NOYIELD  :: 2

process_heap: HANDLE


GetCommandLineA :: () -> string #external
GetProcessHeap :: () -> HANDLE #external

HeapAlloc :: (hHeap: HANDLE, dwFlags: u32, dwBytes: u64) -> *void #external
HeapReAlloc :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void, dwBytes: u64) -> *void #external
HeapFree :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void) -> s32 #external

allocate :: (size: u64) -> *void {
	return HeapAlloc(process_heap, 0, size)
}

reallocate :: (block: *void, size: u64) -> *void {
	if block == null
		return allocate(size)
	else
		return HeapReAlloc(process_heap, 0, block, size)
}

deallocate :: (block: *void) {
	HeapFree(process_heap, 0, block)
}


std_out: HANDLE

init_runtime :: () {
	process_heap = GetProcessHeap()
	std_out = GetStdHandle(STD_OUTPUT_HANDLE)
}

print_buffer :: (buffer: []u8) {
	WriteConsoleA(std_out, buffer.data, cast() buffer.count)
}

SwapBuffers :: (Arg1: HDC) -> s32 #external
wglCreateContext :: (Arg1: HDC) -> HGLRC #external
wglMakeCurrent :: (hdc: HDC, hglrc: HGLRC) -> s32 #external
wglDeleteContext :: (Arg1: HGLRC) -> s32 #external
wglGetCurrentDC :: () -> HDC #external
wglGetProcAddress :: (Arg1: *u8) -> *void #external

ExitProcess :: (uExitCode: u32) #external

PIXELFORMATDESCRIPTOR :: struct {
	nSize: u16 = size_of(PIXELFORMATDESCRIPTOR)
	nVersion: u16 = 1
	dwFlags: u32
	iPixelType: u8
	cColorBits: u8
	cRedBits: u8
	cRedShift: u8
	cGreenBits: u8
	cGreenShift: u8
	cBlueBits: u8
	cBlueShift: u8
	cAlphaBits: u8
	cAlphaShift: u8
	cAccumBits: u8
	cAccumRedBits: u8
	cAccumGreenBits: u8
	cAccumBlueBits: u8
	cDepthBits: u8
	cStencilBits: u8
	cAuxBuffers: u8
	iLayerType: u8
	bReserved: u8
	dwLayerMask: u32
	dwVisibleMask: u32
	dwDamageMask: u32
}

PFD_DOUBLEBUFFER          :: 0x00000001
PFD_STEREO                :: 0x00000002
PFD_DRAW_TO_WINDOW        :: 0x00000004
PFD_DRAW_TO_BITMAP        :: 0x00000008
PFD_SUPPORT_GDI           :: 0x00000010
PFD_SUPPORT_OPENGL        :: 0x00000020
PFD_GENERIC_FORMAT        :: 0x00000040
PFD_NEED_PALETTE          :: 0x00000080
PFD_NEED_SYSTEM_PALETTE   :: 0x00000100
PFD_SWAP_EXCHANGE         :: 0x00000200
PFD_SWAP_COPY             :: 0x00000400
PFD_SWAP_LAYER_BUFFERS    :: 0x00000800
PFD_GENERIC_ACCELERATED   :: 0x00001000
PFD_SUPPORT_DIRECTDRAW    :: 0x00002000
PFD_DIRECT3D_ACCELERATED  :: 0x00004000
PFD_SUPPORT_COMPOSITION   :: 0x00008000
PFD_DEPTH_DONTCARE        :: 0x20000000
PFD_DOUBLEBUFFER_DONTCARE :: 0x40000000
PFD_STEREO_DONTCARE       :: 0x80000000

PFD_TYPE_RGBA:       u8: 0
PFD_TYPE_COLORINDEX: u8: 1

PFD_MAIN_PLANE:     u8: 0
PFD_OVERLAY_PLANE:  u8: 1
PFD_UNDERLAY_PLANE: u8: cast(u8) -1

ChoosePixelFormat :: (hdc: HDC, ppfd: *PIXELFORMATDESCRIPTOR) -> s32 #external
SetPixelFormat :: (hdc: HDC, format: s32, ppfd: *PIXELFORMATDESCRIPTOR) -> s32 #external

QueryPerformanceCounter :: (lpPerformanceCount: *s64) -> s32 #external
QueryPerformanceFrequency :: (lpFrequency: *s64) -> s32 #external

SECURITY_ATTRIBUTES :: struct {
	nLength: u32 = size_of(SECURITY_ATTRIBUTES)
	lpSecurityDescriptor: *void
	bInheritHandle: s32
}

OVERLAPPED :: struct {
	Internal: u64
	InternalHigh: u64
	
	data: union {
		Offset: u64
		Pointer: *void
	}
	
	hEvent: HANDLE
}

CloseHandle :: (hObject: HANDLE) -> s32 #external
CreateFileW :: (lpFileName: *u16, dwDesiredAccess: u32, dwShareMode: u32, lpSecurityAttributes: *SECURITY_ATTRIBUTES = null, dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile : HANDLE = null) -> HANDLE #external
GetFileSizeEx :: (hFile: HANDLE, lpFileSize: *s64) -> s32 #external
ReadFile :: (hFile: HANDLE, lpBuffer: *void, nNumberOfBytesToRead: u32, lpNumberOfBytesRead: *u32, lpOverlapped: *OVERLAPPED = null) -> s32 #external

INVALID_HANDLE_VALUE :: cast(HANDLE) -1

GENERIC_READ    :: 0x8000_0000
GENERIC_WRITE   :: 0x4000_0000
GENERIC_EXECUTE :: 0x2000_0000
GENERIC_ALL     :: 0x1000_0000

FILE_SHARE_DELETE :: 0x4
FILE_SHARE_READ   :: 0x2
FILE_SHARE_WRITE  :: 0x1

CREATE_NEW        :: 1
CREATE_ALWAYS     :: 2
OPEN_EXISTING     :: 3
OPEN_ALWAYS       :: 4
TRUNCATE_EXISTING :: 5

FILE_ATTRIBUTE_READONLY  :: 0x0000_0001
FILE_ATTRIBUTE_HIDDEN    :: 0x0000_0002
FILE_ATTRIBUTE_SYSTEM    :: 0x0000_0004
FILE_ATTRIBUTE_ARCHIVE   :: 0x0000_0020
FILE_ATTRIBUTE_NORMAL    :: 0x0000_0080
FILE_ATTRIBUTE_TEMPORARY :: 0x0000_0100
FILE_ATTRIBUTE_OFFLINE   :: 0x0000_1000
FILE_ATTRIBUTE_ENCRYPTED :: 0x0000_4000

FILE_FLAG_OPEN_NO_RECALL     :: 0x0010_0000
FILE_FLAG_OPEN_REPARSE_POINT :: 0x0020_0000
FILE_FLAG_SESSION_AWARE      :: 0x0080_0000
FILE_FLAG_POSIX_SEMANCTICS   :: 0x0100_0000
FILE_FLAG_BACKUP_SEMANTICS   :: 0x0200_0000
FILE_FLAG_DELETE_ON_CLOSE    :: 0x0400_0000
FILE_FLAG_SEQUENTIAL_SCAN    :: 0x0800_0000
FILE_FLAG_RANDOM_ACCESS      :: 0x1000_0000
FILE_FLAG_NO_BUFFERING       :: 0x2000_0000
FILE_FLAG_OVERLAPPED         :: 0x4000_0000
FILE_FLAG_WRITETHROUGH       :: 0x8000_0000


// @Incomplete, only converts ascii to UTF16, not UTF8
create_wide_string :: (s: string) -> *u16 {
	result: *u16 = allocate((string_length(s) + 1) * size_of(u16))
	
	buffer := result
	
	sbuf := cast(*u8) s
	
	while <<sbuf {
		<<buffer = <<sbuf
		buffer += 1
		sbuf += 1
	}
	
	<<buffer = 0
	
	return result
}

// @Incomplete add multiple return values 
read_entire_file :: (file: string, success: *bool) -> []u8 {
	<<success = true

	result: []u8 = --
	
	filename := create_wide_string(file)
	
	handle := CreateFileW(filename, GENERIC_READ, 0, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN)
	
	if handle == INVALID_HANDLE_VALUE {
		print_string("A");
		<<success = false
	} else {
	
		if GetFileSizeEx(handle, cast() *result.count) {
			result.data = allocate(result.count)
			remaining := result
			
			
			while remaining {
				bytes_read: u32
				
				bytes_to_read := remaining.count
				
				if (bytes_to_read > 0xFFFF_FFFF) {
					bytes_to_read = 0xFFFF_FFFF
				}
				
				if !ReadFile(handle, remaining.data, cast() bytes_to_read, *bytes_read) || bytes_read != bytes_to_read {
					print_string("B");
					<<success = false
					result.count = 0
					deallocate(result.data)
					result.data = null
					break
				}
				
				remaining.count -= bytes_to_read
				remaining.data += bytes_to_read
			}
		} else {
			print_string("C");
			<<success = false
		}
		
		CloseHandle(handle)
	}
	deallocate(filename)
	
	return result
}


