HANDLE :: *void

STD_INPUT_HANDLE: u32: cast() -10
STD_OUTPUT_HANDLE: u32: cast() -11
STD_ERROR_HANDLE: u32: cast() -12

GetStdHandle :: (nStdHandle: u32) -> HANDLE #external

WriteConsoleA :: (hConsoleOutput: HANDLE, lpBuffer: *void, nNumberOfCharactersToWrite: u32, lpNumberOfCharactersWritten: *u32 = null, lpReserved: *void = null) -> bool #external

process_heap: HANDLE


GetCommandLineA :: () -> string #external
GetProcessHeap :: () -> HANDLE #external

HeapAlloc :: (hHeap: HANDLE, dwFlags: u32, dwBytes: u64) -> *void #external
HeapReAlloc :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void, dwBytes: u64) -> *void #external
HeapFree :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void) -> bool #external

allocate :: (size: u64) -> *void {
	return HeapAlloc(process_heap, 0, size)
}

reallocate :: (block: *void, size: u64) -> *void {
	if block == null
		return allocate(size)
	else
		return HeapReAlloc(process_heap, 0, block, size)
}

deallocate :: (block: *void) {
	HeapFree(process_heap, 0, block)
}


std_out: HANDLE

init_runtime :: () {
	process_heap = GetProcessHeap()
	std_out = GetStdHandle(STD_OUTPUT_HANDLE)
}

print_buffer :: (buffer: []u8) {
	WriteConsoleA(std_out, buffer.data, cast() buffer.count)
}
