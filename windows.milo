HINSTANCE :: *struct {
	unused: s32
}


HMODULE :: HINSTANCE

HWND :: *struct {
	unused: s32
}

HICON :: *struct {
	unused: s32
}

HCURSOR :: HICON

HBRUSH :: *struct {
	unused: s32
}

HMENU :: *struct {
	unused: s32
}

HDC :: *struct {
	unused: s32
}

HGLRC :: *struct {
	unused: s32
}
RECT :: struct {
	left: s32
	top: s32
	right: s32
	bottom: s32
}

HANDLE :: *void
HGDIOBJ :: *void

WNDPROC :: (hwnd: HWND, uMsg: u32, wParam: u64, lParam: s64) -> s64
DefWindowProcW :: (hWnd: HWND, Msg: u32, wParam: u64, lParam: s64) -> s64 #external

WNDCLASSW :: struct {
	style: u32
	lpfnWndProc: WNDPROC
	cbClsExtra: s32
	cbWndExtra: s32
	hInstance: HINSTANCE
	hIcon: HICON
	hCursor: HCURSOR
	hbrBackground: HBRUSH
	lpszMenuName: *u16
	lpszClassName: *u16
}

STARTUPINFOW :: struct {
	cb: u32
	lpReserved: *u16
	lpDesktop: *u16
	lpTitle: *u16
	dwX: u32
	dwY: u32
	dwXSize: u32
	dwYSize: u32
	dwXCountChars: u32
	dwYCountChars: u32
	dwFillAttribute: u32
	dwFlags: u32
	wShowWindow: u16
	cbReserved2: u16
	lpReserved2: *u8
	hStdInput: HANDLE
	hStdOutput: HANDLE
	hStdError: HANDLE
}

WS_OVERLAPPED:   u32: 0x0000_0000
WS_POPUP:        u32: 0x8000_0000
WS_CHILD:        u32: 0x4000_0000
WS_MINIMIZE:     u32: 0x2000_0000
WS_VISIBLE:      u32: 0x1000_0000
WS_DISABLED:     u32: 0x0800_0000
WS_CLIPSIBLINGS: u32: 0x0400_0000
WS_CLIPCHILDREN: u32: 0x0200_0000
WS_MAXIMIZE:     u32: 0x0100_0000
WS_CAPTION:      u32: 0x00C0_0000 // WS_BORDER | WS_DLGFRAME
WS_BORDER:       u32: 0x0080_0000
WS_DLGFRAME:     u32: 0x0040_0000
WS_VSCROLL:      u32: 0x0020_0000
WS_HSCROLL:      u32: 0x0010_0000
WS_SYSMENU:      u32: 0x0008_0000
WS_THICKFRAME:   u32: 0x0004_0000
WS_GROUP:        u32: 0x0002_0000
WS_TABSTOP:      u32: 0x0001_0000

WS_MINIMIZEBOX:  u32: 0x0002_0000
WS_MAXIMIZEBOX:  u32: 0x0001_0000

WS_TILED :: WS_OVERLAPPED
WS_ICONIC :: WS_MINIMIZE
WS_SIZEBOX :: WS_THICKFRAME
WS_TILEDWINDOW :: WS_OVERLAPPEDWINDOW

WS_OVERLAPPEDWINDOW: u32: 0x00CF_0000 // WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX

WS_POPUPWINDOW: u32: 0x8088_0000 // WS_POPUP | WS_BORDER | WS_SYSMENU

WS_CHILDWINDOW :: WS_CHILD

WS_EX_DLGMODALFRAME:       u32: 0x0000_0001
WS_EX_NOPARENTNOTIFY:      u32: 0x0000_0004
WS_EX_TOPMOST:             u32: 0x0000_0008
WS_EX_ACCEPTFILES:         u32: 0x0000_0010
WS_EX_TRANSPARENT:         u32: 0x0000_0020
WS_EX_MDICHILD:            u32: 0x0000_0040
WS_EX_TOOLWINDOW:          u32: 0x0000_0080
WS_EX_WINDOWEDGE:          u32: 0x0000_0100
WS_EX_CLIENTEDGE:          u32: 0x0000_0200
WS_EX_CONTEXTHELP:         u32: 0x0000_0400
WS_EX_RIGHT:               u32: 0x0000_1000
WS_EX_LEFT:                u32: 0x0000_0000
WS_EX_RTLEADING:           u32: 0x0000_2000
WS_EX_LTLEADING:           u32: 0x0000_0000
WS_EX_LEFTSCROLLBAR:       u32: 0x0000_4000
WS_EX_RIGHTSCROLLBAR:      u32: 0x0000_0000
WS_EX_CONTROLPARENT:       u32: 0x0001_0000
WS_EX_STATICEDGE:          u32: 0x0002_0000
WS_EX_APPWINDOW:           u32: 0x0004_0000
WS_EX_LAYERED:             u32: 0x0008_0000
WS_EX_NOINHERITLAYOUT:     u32: 0x0010_0000
WS_EX_NOREDIRECTIONBITMAP: u32: 0x0020_0000
WS_EX_LAYOUTRTL:           u32: 0x0200_0000
WS_EX_COMPOSITED:          u32: 0x0400_0000
WS_EX_NOACTIBE:            u32: 0x0800_0000

CS_VREDRAW:          u32: 0x0000_0001
CS_HREDRAW:          u32: 0x0000_0002
CS_DBLCLKS:          u32: 0x0000_0008
CS_OWNDC:            u32: 0x0000_0020
CS_CLASSDC:          u32: 0x0000_0040
CS_PARENTDC:         u32: 0x0000_0080
CS_NOCLOSE:          u32: 0x0000_0200
CS_SAVEBITS:         u32: 0x0000_0800
CS_BYTEALIGNCLIENT:  u32: 0x0000_1000
CS_BYTEALIGNWINDOW:  u32: 0x0000_2000
CS_GLOBALCLASS:      u32: 0x0000_4000
CS_IME:              u32: 0x0001_0000
CS_DROPSHADOW:       u32: 0x0002_0000


WS_EX_OVERLAPPEDWINDOW: u32: 0x0000_0300 // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
WS_EX_PALETTE_WINDOW:   u32: 0x0000_0188 // WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST

STARTF_USESHOWWINDOW:    u32: 0x0000_0001
STARTF_USESIZE:          u32: 0x0000_0002
STARTF_USEPOSITION:      u32: 0x0000_0004
STARTF_USECOUNTCHARS:    u32: 0x0000_0008
STARTF_USEFILLATTRIBUTE: u32: 0x0000_0010
STARTF_RUNFULLSCREEN:    u32: 0x0000_0020
STARTF_FORCEONFEEDBACK:  u32: 0x0000_0040
STARTF_FORCEOFFFEEDBACK: u32: 0x0000_0080
STARTF_USESTDHANDLES:    u32: 0x0000_0100

SW_HIDE:            u16: 0
SW_SHOWNORMAL:      u16: 1
SW_NORMAL:          u16: 1
SW_SHOWMINIMIZED:   u16: 2
SW_SHOWMAXIMIZED:   u16: 3
SW_MAXIMIZE:        u16: 3
SW_SHOWNOACTIVATE:  u16: 4
SW_SHOW:            u16: 5
SW_MINIMIZE:        u16: 6
SW_SHOWMINNOACTIVE: u16: 7
SW_SHOWNA:          u16: 8
SW_RESTORE:         u16: 9
SW_SHOWDEFAULT:     u16: 10
SW_FORCEMINIMIZE:   u16: 11
SW_MAX:             u16: 11

POINT :: struct {
	x: s32
	y: s32
}

MSG :: struct {
	hwnd: HWND
	message: u32
	wParam: u64
	lParam: s64
	time: u32
	pt: POINT
}


CW_USEDEFAULT :: cast(s32) 0x80000000

GetStartupInfoW :: (lpStartupInfo: *STARTUPINFOW) #external

CreateWindowExW :: (dwExStyle: u32 = 0, lpClassName: *u16, lpWindowName: *u16, dwStyle: u32 = WS_OVERLAPPEDWINDOW, X: s32 = CW_USEDEFAULT, Y: s32 = CW_USEDEFAULT, nWidth: s32, nHeight: s32, hWndParent: HWND = null, hMenu: HMENU = null, hInstance: HINSTANCE, lpParam: *void = null) -> HWND #external

PAINTSTRUCT :: struct {
	hdc: HDC
	fErase: s32
	rcPaint: RECT
	fRestore: s32
	fIncUpdate: s32
	rgbReserved: [32]u8
}

BeginPaint :: (hWnd: HWND, lpPaint: *PAINTSTRUCT) -> HDC #external
EndPaint :: (hWnd: HWND, lpPaint: *PAINTSTRUCT) -> s32 #external

PatBlt :: (hdc: HDC, x: s32, y: s32, w: s32, h: s32, rop: u32) -> s32 #external

BLACKNESS: u32: 0x0000_0042
WHITENESS: u32: 0x00FF_0062

GetStockObject :: (i: s32) -> HGDIOBJ #external

WHITE_BRUSH:         s32: 0
LTGRAY_BRUSH:        s32: 1
GRAY_BRUSH:          s32: 2
DKGRAY_BRUSH:        s32: 3
BLACK_BRUSH:         s32: 4
NULL_BRUSH:          s32: 5
HOLLOW_BRUSH:        s32: NULL_BRUSH
WHITE_PEN:           s32: 6
BLACK_PEN:           s32: 7
NULL_PEN:            s32: 8
OEM_FIXED_FONT:      s32: 10
ANSI_FIXED_FONT:     s32: 11
ANSI_VAR_FONT:       s32: 12
SYSTEM_FONT:         s32: 13
DEVICE_DEFAULT_FONT: s32: 14
DEFAULT_PALETTE:     s32: 15
SYSTEM_FIXED_FONT:   s32: 16
DEFAULT_GUI_FONT:    s32: 17
DC_BRUSH:            s32: 18
DC_PEN:              s32: 19

GetClientRect :: (hWnd: HWND, lpRect: *RECT) -> s32 #external

STD_INPUT_HANDLE: u32: cast() -10
STD_OUTPUT_HANDLE: u32: cast() -11
STD_ERROR_HANDLE: u32: cast() -12

GetLastError :: () -> u32 #external

GetStdHandle :: (nStdHandle: u32) -> HANDLE #external
GetModuleHandleW :: (lpModuleName: *u8) -> HMODULE #external

WriteConsoleA :: (hConsoleOutput: HANDLE, lpBuffer: *void, nNumberOfCharactersToWrite: u32, lpNumberOfCharactersWritten: *u32 = null, lpReserved: *void = null) -> s32 #external

RegisterClassW :: (lpWndClass: *WNDCLASSW) -> u16 #external

ShowWindow :: (hWnd: HWND, nCmdShow: s32) -> s32 #external

GetMessageW :: (lpMsg: *MSG, hWnd: HWND,  wMsgFilterMin: u32, wMsgFilterMax: u32) -> s32 #external
PeekMessageW :: (lpMsg: *MSG, hWnd: HWND,  wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMessage: u32) -> s32 #externalTranslateMessage :: (lpMsg: *MSG) -> s32 #external
DispatchMessageW :: (lpMsg: *MSG) -> s32 #external

GetDC :: (hWnd: HWND) -> HDC #external
ReleaseDC :: (hWnd: HWND, hdc: HDC) -> s32 #external
DeleteDC :: (hdc: HDC) -> s32 #external

WM_NULL:            u32: 0x0000
WM_CREATE:          u32: 0x0001
WM_DESTROY:         u32: 0x0002
WM_MOVE:            u32: 0x0003
WM_SIZE:            u32: 0x0005
WM_ACTIVATE:        u32: 0x0006
WM_SETFOCUS:        u32: 0x0007
WM_KILLFOCUES:      u32: 0x0008
WM_ENABLE:          u32: 0x000A
WM_SETREDRAW:       u32: 0x000B
WM_SETTEXT:         u32: 0x000C
WM_GETTEXT:         u32: 0x000D
WM_GETTEXTLENGTH:   u32: 0x000E
WM_PAINT:           u32: 0x000F
WM_CLOSE:           u32: 0x0010
WM_QUERYENDSESSION: u32: 0x0011
WM_QUIT:            u32: 0x0012
WM_QUERYOPEN:       u32: 0x0013
WM_ERASEBKGND:      u32: 0x0014
WM_SYSCOLORCHANGE:  u32: 0x0015
WM_ENDSESSION:      u32: 0x0016
WM_SHOWWINDOW:      u32: 0x0018
WM_WININICHANGE:    u32: 0x001A
WM_DEVMODECHANGE:   u32: 0x001B
WM_ACTIVATEAPP:     u32: 0x001C
WM_FONTCHANGE:      u32: 0x001D
WM_TIMECHANGE:      u32: 0x001E
WM_CANCELMODE:      u32: 0x001F
WM_SETCURSOR:       u32: 0x0020
WM_MOUSEACTIVATE:   u32: 0x0021
WM_CHILDACTIVATE:   u32: 0x0022
WM_QUEUESYNC:       u32: 0x0023
WM_GETMINMAXINFO:   u32: 0x0024

DestroyWindow :: (hWnd: HWND) -> s32 #external
PostQuitMessage :: (nExitCode: s32) #external

PM_NOREMOVE: u32: 0
PM_REMOVE:   u32: 1
PM_NOYIELD:  u32: 2

process_heap: HANDLE


GetCommandLineA :: () -> string #external
GetProcessHeap :: () -> HANDLE #external

HeapAlloc :: (hHeap: HANDLE, dwFlags: u32, dwBytes: u64) -> *void #external
HeapReAlloc :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void, dwBytes: u64) -> *void #external
HeapFree :: (hHeap: HANDLE, dwFlags: u32, lpMem: *void) -> s32 #external

allocate :: (size: u64) -> *void {
	return HeapAlloc(process_heap, 0, size)
}

reallocate :: (block: *void, size: u64) -> *void {
	if block == null
		return allocate(size)
	else
		return HeapReAlloc(process_heap, 0, block, size)
}

deallocate :: (block: *void) {
	HeapFree(process_heap, 0, block)
}


std_out: HANDLE

init_runtime :: () {
	process_heap = GetProcessHeap()
	std_out = GetStdHandle(STD_OUTPUT_HANDLE)
}

print_buffer :: (buffer: []u8) {
	WriteConsoleA(std_out, buffer.data, cast() buffer.count)
}

SwapBuffers :: (Arg1: HDC) -> s32 #external
wglCreateContext :: (Arg1: HDC) -> HGLRC #external
wglMakeCurrent :: (hdc: HDC, hglrc: HGLRC) -> s32 #external
wglDeleteContext :: (Arg1: HGLRC) -> s32 #external
wglGetCurrentDC :: () -> HDC #external
wglGetProcAddress :: (Arg1: *u8) -> *void #external

ExitProcess :: (uExitCode: u32) #external

PIXELFORMATDESCRIPTOR :: struct {
	nSize: u16 = size_of(PIXELFORMATDESCRIPTOR)
	nVersion: u16 = 1
	dwFlags: u32
	iPixelType: u8
	cColorBits: u8
	cRedBits: u8
	cRedShift: u8
	cGreenBits: u8
	cGreenShift: u8
	cBlueBits: u8
	cBlueShift: u8
	cAlphaBits: u8
	cAlphaShift: u8
	cAccumBits: u8
	cAccumRedBits: u8
	cAccumGreenBits: u8
	cAccumBlueBits: u8
	cDepthBits: u8
	cStencilBits: u8
	cAuxBuffers: u8
	iLayerType: u8
	bReserved: u8
	dwLayerMask: u32
	dwVisibleMask: u32
	dwDamageMask: u32
}

PFD_DOUBLEBUFFER:          u32: 0x00000001
PFD_STEREO:                u32: 0x00000002
PFD_DRAW_TO_WINDOW:        u32: 0x00000004
PFD_DRAW_TO_BITMAP:        u32: 0x00000008
PFD_SUPPORT_GDI:           u32: 0x00000010
PFD_SUPPORT_OPENGL:        u32: 0x00000020
PFD_GENERIC_FORMAT:        u32: 0x00000040
PFD_NEED_PALETTE:          u32: 0x00000080
PFD_NEED_SYSTEM_PALETTE:   u32: 0x00000100
PFD_SWAP_EXCHANGE:         u32: 0x00000200
PFD_SWAP_COPY:             u32: 0x00000400
PFD_SWAP_LAYER_BUFFERS:    u32: 0x00000800
PFD_GENERIC_ACCELERATED:   u32: 0x00001000
PFD_SUPPORT_DIRECTDRAW:    u32: 0x00002000
PFD_DIRECT3D_ACCELERATED:  u32: 0x00004000
PFD_SUPPORT_COMPOSITION:   u32: 0x00008000
PFD_DEPTH_DONTCARE:        u32: 0x20000000
PFD_DOUBLEBUFFER_DONTCARE: u32: 0x40000000
PFD_STEREO_DONTCARE:       u32: 0x80000000

PFD_TYPE_RGBA:       u8: 0
PFD_TYPE_COLORINDEX: u8: 1

PFD_MAIN_PLANE:     u8: 0
PFD_OVERLAY_PLANE:  u8: 1
PFD_UNDERLAY_PLANE: u8: cast(u8) -1

ChoosePixelFormat :: (hdc: HDC, ppfd: *PIXELFORMATDESCRIPTOR) -> s32 #external
SetPixelFormat :: (hdc: HDC, format: s32, ppfd: *PIXELFORMATDESCRIPTOR) -> s32 #external

QueryPerformanceCounter :: (lpPerformanceCount: *s64) -> s32 #external
QueryPerformanceFrequency :: (lpFrequency: *s64) -> s32 #external

SECURITY_ATTRIBUTES :: struct {
	nLength: u32 = size_of(SECURITY_ATTRIBUTES)
	lpSecurityDescriptor: *void
	bInheritHandle: s32
}

OVERLAPPED :: struct {
	Internal: u64
	InternalHigh: u64
	
	data: union {
		Offset: u64
		Pointer: *void
	}
	
	hEvent: HANDLE
}

CloseHandle :: (hObject: HANDLE) -> s32 #external
CreateFileW :: (lpFileName: *u16, dwDesiredAccess: u32, dwShareMode: u32, lpSecurityAttributes: *SECURITY_ATTRIBUTES = null, dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile : HANDLE = null) -> HANDLE #external
GetFileSizeEx :: (hFile: HANDLE, lpFileSize: *s64) -> s32 #external
ReadFile :: (hFile: HANDLE, lpBuffer: *void, nNumberOfBytesToRead: u32, lpNumberOfBytesRead: *u32, lpOverlapped: *OVERLAPPED = null) -> s32 #external

INVALID_HANDLE_VALUE :: cast(HANDLE) -1

GENERIC_READ:    u32: 0x8000_0000
GENERIC_WRITE:   u32: 0x4000_0000
GENERIC_EXECUTE: u32: 0x2000_0000
GENERIC_ALL:     u32: 0x1000_0000

FILE_SHARE_DELETE: u32: 0x4
FILE_SHARE_READ:   u32: 0x2
FILE_SHARE_WRITE:  u32: 0x1

CREATE_NEW:        u32: 1
CREATE_ALWAYS:     u32: 2
OPEN_EXISTING:     u32: 3
OPEN_ALWAYS:       u32: 4
TRUNCATE_EXISTING: u32: 5

FILE_ATTRIBUTE_READONLY:  u32: 0x0000_0001
FILE_ATTRIBUTE_HIDDEN:    u32: 0x0000_0002
FILE_ATTRIBUTE_SYSTEM:    u32: 0x0000_0004
FILE_ATTRIBUTE_ARCHIVE:   u32: 0x0000_0020
FILE_ATTRIBUTE_NORMAL:    u32: 0x0000_0080
FILE_ATTRIBUTE_TEMPORARY: u32: 0x0000_0100
FILE_ATTRIBUTE_OFFLINE:   u32: 0x0000_1000
FILE_ATTRIBUTE_ENCRYPTED: u32: 0x0000_4000

FILE_FLAG_OPEN_NO_RECALL:     u32: 0x0010_0000
FILE_FLAG_OPEN_REPARSE_POINT: u32: 0x0020_0000
FILE_FLAG_SESSION_AWARE:      u32: 0x0080_0000
FILE_FLAG_POSIX_SEMANCTICS:   u32: 0x0100_0000
FILE_FLAG_BACKUP_SEMANTICS:   u32: 0x0200_0000
FILE_FLAG_DELETE_ON_CLOSE:    u32: 0x0400_0000
FILE_FLAG_SEQUENTIAL_SCAN:    u32: 0x0800_0000
FILE_FLAG_RANDOM_ACCESS:      u32: 0x1000_0000
FILE_FLAG_NO_BUFFERING:       u32: 0x2000_0000
FILE_FLAG_OVERLAPPED:         u32: 0x4000_0000
FILE_FLAG_WRITETHROUGH:       u32: 0x8000_0000


// @Incomplete, only converts ascii to UTF16, not UTF8
create_wide_string :: (s: string) -> *u16 {
	result: *u16 = allocate((string_length(s) + 1) * size_of(u16))
	
	buffer := result
	
	sbuf := cast(*u8) s
	
	while <<sbuf {
		<<buffer = <<sbuf
		buffer += 1
		sbuf += 1
	}
	
	<<buffer = 0
	
	return result
}

// @Incomplete add multiple return values 
read_entire_file :: (file: string, success: *bool) -> []u8 {
	<<success = true

	result: []u8 = --
	
	filename := create_wide_string(file)
	
	handle := CreateFileW(filename, GENERIC_READ, 0, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN)
	
	if handle == INVALID_HANDLE_VALUE {
		print_string("A");
		<<success = false
	} else {
	
		if GetFileSizeEx(handle, cast() *result.count) {
			result.data = allocate(result.count)
			remaining := result
			
			
			while remaining {
				bytes_read: u32
				
				bytes_to_read := remaining.count
				
				if (bytes_to_read > 0xFFFF_FFFF) {
					bytes_to_read = 0xFFFF_FFFF
				}
				
				if !ReadFile(handle, remaining.data, cast() bytes_to_read, *bytes_read) || bytes_read != bytes_to_read {
					print_string("B");
					<<success = false
					result.count = 0
					deallocate(result.data)
					result.data = null
					break
				}
				
				remaining.count -= bytes_to_read
				remaining.data += bytes_to_read
			}
		} else {
			print_string("C");
			<<success = false
		}
		
		CloseHandle(handle)
	}
	deallocate(filename)
	
	return result
}


